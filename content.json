{"meta":{"title":"阿龙的小型博客","subtitle":null,"description":null,"author":"wang lv long","url":"https://wll-1017065322.github.io","root":"/"},"pages":[{"title":"","date":"2019-04-25T15:58:38.691Z","updated":"2019-04-25T15:58:38.691Z","comments":true,"path":"about/index.html","permalink":"https://wll-1017065322.github.io/about/index.html","excerpt":"","text":"简历"},{"title":"tags","date":"2017-01-17T13:39:14.000Z","updated":"2019-04-25T15:58:38.696Z","comments":true,"path":"tag/index.html","permalink":"https://wll-1017065322.github.io/tag/index.html","excerpt":"","text":"tags"},{"title":"Gallery","date":"2017-01-17T13:39:03.000Z","updated":"2019-04-25T15:58:38.693Z","comments":true,"path":"gallery/index.html","permalink":"https://wll-1017065322.github.io/gallery/index.html","excerpt":"","text":"图库"},{"title":"group","date":"2017-01-17T13:05:04.000Z","updated":"2019-04-25T15:58:38.694Z","comments":true,"path":"group/index.html","permalink":"https://wll-1017065322.github.io/group/index.html","excerpt":"","text":"团队"}],"posts":[{"title":"","slug":"作用域链","date":"2019-04-28T14:25:41.135Z","updated":"2019-04-28T13:58:43.538Z","comments":true,"path":"2019/04/28/作用域链/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/作用域链/","excerpt":"","text":"12A scope chain is a list of objects that are searched for identifiers appear in the code of the context.作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。 标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。例如，当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明（或者也不是某个参数名），那么这个变量就可以称为自由变量[free variable]。那么我们搜寻这些自由变量就需要用到作用域链。 在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如with或者catch语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]。 当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。 1234567891011var x = 10; (function foo() &#123; var y = 20; (function bar() &#123; var z = 30; // &quot;x&quot;和&quot;y&quot;是自由变量 // 会在作用域链的下一个对象中找到（函数”bar”的互动对象之后） console.log(x + y + z); &#125;)();&#125;)(); 我们假设作用域链的对象联动是通过一个叫做parent的属性，它是指向作用域链的下一个对象。这可以在Rhino Code中测试一下这种流程，这种技术也确实在ES5环境中实现了(有一个称为outer链接).当然也可以用一个简单的数据来模拟这个模型。使用parent的概念，我们可以把上面的代码演示成如下的情况。（因此，父级变量是被存在函数的[[Scope]]属性中的）。 图 9. 作用域链 在代码执行过程中，如果使用with或者catch语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻。 ​ 首先在原本的作用域链 ​ 每一个链接点的作用域的链（如果这个链接点是有prototype的话） 我们再看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435Object.prototype.x = 10; var w = 20;var y = 30; // 在SpiderMonkey全局对象里// 例如，全局上下文的变量对象是从&quot;Object.prototype&quot;继承到的// 所以我们可以得到“没有声明的全局变量”// 因为可以从原型链中获取 console.log(x); // 10 (function foo() &#123; // &quot;foo&quot; 是局部变量 var w = 40; var x = 100; // &quot;x&quot; 可以从&quot;Object.prototype&quot;得到，注意值是10哦 // 因为&#123;z: 50&#125;是从它那里继承的 with (&#123;z: 50&#125;) &#123; console.log(w, x, y , z); // 40, 10, 30, 50 &#125; // 在&quot;with&quot;对象从作用域链删除之后 // x又可以从foo的上下文中得到了，注意这次值又回到了100哦 // &quot;w&quot; 也是局部变量 console.log(x, w); // 100, 40 // 在浏览器里 // 我们可以通过如下语句来得到全局的w值 console.log(window.w); // 20 &#125;)(); 我们就会有如下结构图示。这表示，在我们去搜寻parent之前，首先会去proto的链接中。 图 10. with增大的作用域链 注意，不是所有的全局对象都是由Object.prototype继承而来的。上述图示的情况可以在SpiderMonkey中测试。 只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处——我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 销毁(destroyed) ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在ECMAScript中与作用域链直接相关，被称为 (词法)闭包((lexical) closure)。","categories":[],"tags":[]},{"title":"","slug":"执行上下文栈","date":"2019-04-28T14:25:41.132Z","updated":"2019-04-28T14:03:00.053Z","comments":true,"path":"2019/04/28/执行上下文栈/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/执行上下文栈/","excerpt":"","text":"在ECMASscript中的代码有三种类型：global, function和eval。 每一种代码的执行都需要依赖自身的上下文。当然global的上下文可能涵盖了很多的function和eval的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。 注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 12345678function foo(bar) &#123;&#125;// 调用相同的function，每次都会产生3个不同的上下文//（包含不同的状态，例如参数bar的值）foo(10);foo(20);foo(30); 一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。 激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。 当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，称为进行中的上下文[running/active execution context]. 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。在这个caller结束之后，会继续触发其他的上下文。一个callee可以用返回（return）或者抛出异常（exception）来结束自身的上下文。 如下图，所有的ECMAScript的程序执行都可以看做是一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。 图 4. 执行上下文栈 当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。 见图5，有一个函数上下文“EC1″和一个全局上下文“Global EC”，下图展现了从“Global EC”进入和退出“EC1″时栈的变化: 图 5. 执行上下文栈的变化 ECMAScript运行时系统就是这样管理代码的执行。 关于ECMAScript执行上下文栈的内容请查阅本系列教程的第11章执行上下文(Execution context)。 如上所述，栈中每一个执行上下文可以表示为一个对象。让我们看看上下文对象的结构以及执行其代码所需的 状态(state) 。 执行上下文(Execution Context)一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。这个图示就是一个context的结构。 图 6. 上下文结构 除了这3个所需要的属性(变量对象(variable object)，this指针(this value)，作用域链(scope chain) )，执行上下文根据具体实现还可以具有任意额外属性。接着，让我们仔细来看看这三个属性。","categories":[],"tags":[]},{"title":"","slug":"探究同步异步工作原理","date":"2019-04-28T14:25:41.127Z","updated":"2019-04-28T10:26:28.569Z","comments":true,"path":"2019/04/28/探究同步异步工作原理/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/探究同步异步工作原理/","excerpt":"","text":"前言 JS引擎在运行同步代码的时候按照顺序运行的方式，而如果遇见异步代码将会短暂挂起，放入事件循环队列(Event Loop)末端，一次执行。 12345678//you may have seen the following codefor (var i = 0; i &lt; 3; i++) &#123; setTimeout(function timeoutHandle() &#123; console.log(i); &#125;,1000);&#125; 但是如果如上述代码所示，加上一个定时器又如何理解呢？在同步代码循环结束完毕之后，三个异步事件挂起，等到1秒时间到了之后，三个异步事件依次放入事件循环队列中执行，而同步代码中循环中的每一次迭代都会给自己捕获一个i的副本，但是根据作用域的工作原理，实际情况是尽管循环中的三个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域中，因此实际只有一个i。 探析 对于var关键字声明变量有着诸多诟病，那就是会造成污染全局变量的风险，比如上述的for循环中，假如在for循环体之外再次打印，引擎依旧会给出泄露出去的全局变量i，当然这是很危险的。我们不妨用一下let关键字。 12345for (let i = 0; i &lt; 3; i++ )&#123; setTimeout(function timeoutHandle() &#123; console.log(i); &#125;);&#125; 你会惊喜的发现打印结果是预期顺序。 那是因为for循环的头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次。每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 原始链接： https://bigbigdreamer.github.io/76f810b0/","categories":[],"tags":[]},{"title":"","slug":"前端演变的理解","date":"2019-04-28T14:25:41.124Z","updated":"2019-04-28T13:41:30.805Z","comments":true,"path":"2019/04/28/前端演变的理解/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/前端演变的理解/","excerpt":"","text":"什么是前端web应用是一种运行在浏览器中的软件，这些软件的图形用户界面（Graphical User Interface, 即GUI）称为前端。（前端是一种GUI应用） 前后端不分离时代 web1.0早期，前后端开发是一体的，网站开发采用后端为主的mvc模式，前端相当于后端的view层。前端的主要工作是编写页面模板，后端代码根据浏览器请求，读取模板，替换变量，生成静态页面，发送给浏览器。 Ajax技术诞生 web2.0 AJAX不是JavaScript的规范，Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 2005年 Ajax 正式提出，前后端分工逐渐清晰，前后端协作的关键是Ajax接口。前端不再是后端的模板，前后端分离，网页也从静态网页转为动态网页。前端开始逐渐复杂。 前端mv*为了降低前端开发的复杂度，出现了大量前端MV*框架比如Backbone，KnockoutJS、AngularJS 等等，对代码进行合理的分层，如models，controllers，view，viewmodel等，让代码各施其职。 前端工程化随着前后端分工的清晰，前端工作的复杂度的增高，开始出现了前端工程化的概念，前端工程化分为几个阶段 技术选型 构建优化 js/css模块化 组件化开发与资源管理 构建优化比如grunt，gulp，对网站资源进行优化如代码压缩，校验，资源合并，对简化前端开发中很多复杂重复的工作，提高开发效率，和执行运行性能。 模块化js的模块化方案很多，如AMD/CommonJS/ES6 Module等css的模块化主要是靠less，sass，stylus等预处理器的import/mixin来支持实现模块化打包工具webpack，parcel，browserify等等 模块化的主要思想在于分而治之，是复杂系统开发和维护的基石。将一个复杂的应用，分成多个更小的部分进行开发与维护，最后再由每一个模块相互作用构成我们的整个应用。 组件化和资源管理组件化也是对分治思想的一种实践，前端作为一种GUI软件，在大型应用中还需要对ui进行组件化开发 页面上每个独立的可视/可交互区域为一个组件 组件间可以自由组合，替换 页面为组件的容器 静态资源管理目前大多数的前端应用都是远程部署，运行时增量下载的GUI软件由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案等等有关前端工程化更详细的了解可到 前端工程 了解 大前端随着nodejs的出现，JavaScript的覆盖范围扩大，大前端的概念也开始出现。大前端的原始定义可以定义为前端技术的扩大化。再后来react native的出现，JavaScript的覆盖范围再一次扩大，拥有了开发跨平台app的能力，大前端的概念进一步加深。前端的工作不再局限于“前端”，必要时时兼顾后端和移动端开发。 总结所以我认为现在的前端应该具备的技术有： html，css，JavaScript过硬的基础。 了解模块化，工程化 深入学习一门JavaScript框架 gulp等自动化构建工具 webpack等模块化资源打包工具 scss，es6等提高生成效率的工具 一门后端语言 有能力的话学习如react native等跨平台技术 作者：holyZheng https://github.com/HolyZheng/holyZheng-blog/issues/1","categories":[],"tags":[]},{"title":"","slug":"前端工程与性能优化","date":"2019-04-28T14:25:41.122Z","updated":"2019-04-28T13:40:11.886Z","comments":true,"path":"2019/04/28/前端工程与性能优化/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/前端工程与性能优化/","excerpt":"","text":"优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 开启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 链接地址： fouber/blog#10 http://velocity.oreilly.com.cn/2010/index.php?func=session&amp;name=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96","categories":[],"tags":[]},{"title":"","slug":"前端工程(基础)","date":"2019-04-28T14:25:41.119Z","updated":"2019-04-28T14:01:23.441Z","comments":true,"path":"2019/04/28/前端工程(基础)/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/前端工程(基础)/","excerpt":"","text":"喂喂喂，那个切图的，把页面写好就发给研发工程师套模板吧。 你好，切图仔。 不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。 只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。 前端，是一种GUI软件现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台…… 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件： 尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。 历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！ 前端工程的三个阶段现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段： 第一阶段：库/框架选型 前端工程建设的第一项任务就是根据项目特征进行技术选型。 基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。 第二阶段：简单构建优化 选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。 第三阶段：JS/CSS模块化开发 分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。 很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。 JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。 然而，做到这些就够了么？Naive！ 第四阶段 前端是一种技术问题较少、工程问题较多的软件开发领域。 当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如： 大体量：多功能、多页面、多状态、多系统； 大规模：多人甚至多团队合作开发； 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。 扩展阅读：大公司里怎样开发和部署前端代码？ 这些无疑是一系列严肃的系统工程问题。 前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。 到底，缺什么呢？ 没有银弹读过《人月神话》的人应该都听说过，软件工程 没有银弹。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔） 前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。 重你妹！你的脑容量只有4K吗？ 工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！ 2011年我有幸参与到 FIS 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。 这些经历让我明悟了一个道理： 进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。 第一件事：组件化开发分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求： 如上图，这是我所信仰的前端组件化开发理念，简单解读一下： 页面上的每个 独立的 可视/可交互区域视为一个组件； 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护； 由于组件具有独立性，因此组件与组件之间可以 自由组合； 页面只不过是组件的容器，负责组合组件形成功能完整的界面； 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。 其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。 组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板： 不同的技术选型决定了不同的组件封装和调用策略。 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分： 由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。 结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念： 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子： 示意图 描述 整个Web应用由页面组成 页面由组件组成 一个组件一个目录，资源就近维护 组件可组合， 组件的JS可依赖其他JS模块， CSS可依赖其他CSS单元 综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构： 如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。 以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。 吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。 第二件事：“智能”静态资源管理上面提到的模块化/组件化开发，仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了。 很明显，模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。然而前端与客户端GUI软件有一个很大的不同： 前端是一种远程部署，运行时增量下载的GUI软件 前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。 上图展示了一款界面繁多功能丰富的应用，如果采用Web实现，相信也是不小的体量，如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。 这正是Web应用“免安装”的魅力所在。 由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。 所以我觉得： 第四阶段前端开发最迫切需要做好的就是在基础架构中贯彻增量原则。 相信这种贯彻不会随着时间的推移而改变，在可预见的未来，无论在HTTP1.x还是HTTP2.0时代，无论在ES5亦或者ES6/7时代，无论是AMD/CommonJS/UMD亦或者ES6 module时代，无论端内技术如何变迁，我们都有足够充分的理由要做好前端程序资源的增量加载。 正如前面说到的，第三阶段前端工程缺少点什么呢？我觉得是在其基础架构中缺少这样一种“智能”的资源加载方案。没有这样的方案，很难将前端应用的规模发展到第四阶段，很难实现落地前面介绍的那种组件化开发方案，也很难让多方合作高效率的完成一项大型应用的开发，并保证其最终运行性能良好。在第四阶段，我们需要强大的工程化手段来管理”玩具般简单“的前端开发。 在我的印象中，Facebook是这方面探索的伟大先驱之一，早在2010年的Velocity China大会上，来自Facebook的David Wei博士就为业界展示了他们令人惊艳的静态网页资源管理和优化技术。 David Wei博士在当年的交流会上提到过一些关于Facebook的一些产品数据： Facebook整站有10000+个静态资源； 每个静态资源都有可能被翻译成超过100种语言版本； 每种资源又会针对浏览器生成3种不同的版本； 要针对不同带宽的用户做5种不同的打包方法； 有3、4个不同的用户组，用于小批次体验新的产品功能； 还要考虑不同的送达方法，可以直接送达，或者通过iframe的方式提升资源并行加载的速度； 静态资源的压缩和非压缩状态可切换，用于调试和定位线上问题 这是一个状态爆炸的问题，将所有状态乘起来，整个网站的资源组合方式会达到几百万种之多（去重之后统计大概有300万种组合方式）。支撑这么大规模前端项目运行的底层架构正是魏博士在那次演讲中分享的Static Resource Management System(静态资源管理系统)，用以解决Facebook项目中有关前端工程的3D问题（Development，Deployment，Debugging）。 那段时间 FIS 项目正好遇到瓶颈，当时的FIS还是一个用php写的task-based构建工具，那时候对于前端工程的认知度很低，觉得前端构建不就是几个压缩优化校验打包任务的组合吗，写好流程调度，就针对不同需求写插件呗，看似非常简单。但当我们支撑越来越多的业务团队，接触到各种不同的业务场景时，我们深刻的感受到task-based工具的粗糙，团队每天疲于根据各种业务场景编写各种打包插件，构建逻辑异常复杂，隐隐看到不可控的迹象。 我们很快意识到把基础架构放到构建工具中实现是一件很愚蠢的事，试图依靠构建工具实现各种优化策略使得构建变成了一个巨大的黑盒，一旦发生问题，定位起来非常困难，而且每种业务场景都有不同的优化需求，构建工具只能通过静态分析来优化加载，具有很大的局限性，单页面/多页面/PC端/移动端/前端渲染/后端渲染/多语言/多皮肤/高级优化等等资源加载问题，总不能给每个都写一套工具吧，更何况这些问题彼此之间还可以有多种组合应用，工具根本写不过来。 Facebook的做法无疑为我们亮起了一盏明灯，不过可惜它并不开源（不是技术封锁，而是这个系统依赖FB体系中的其他方面，通用性不强，开源意义不大），我们只能尝试挖掘相关信息，网上对它的完整介绍还是非常非常少，分析facebook的前端代码也没有太多收获，后来无意中发现了facebook使用的项目管理工具phabricator中的一个静态管理方案Celerity，以及相关的说明，看它的描述很像是Facebook静态资源管理系统的一个mini版！ 简单看过整个系统之后发现原理并不复杂（小而美的典范），它是通过一个小工具扫描所有静态资源，生成一张资源表，然后有一个PHP实现的资源管理框架（Celerity）提供了资源加载接口，替代了传统的script/link等静态的资源加载标签，最终通过查表来加载资源。 虽然没有真正看过FB的那套系统，但眼前的这个小小的框架给了当时的我们足够多的启示： 静态资源管理系统 = 资源表 + 资源加载框架 多么优雅的实现啊！ 资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容，比如： 12345678910111213141516&#123; &quot;a.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/a.5f100fa.js&quot;, &quot;dep&quot;: [ &quot;b.js&quot;, &quot;a.css&quot; ] &#125;, &quot;a.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/a.63cf374.css&quot;, &quot;dep&quot;: [ &quot;button.css&quot; ] &#125;, &quot;b.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/b.97193bf.js&quot; &#125;, &quot;button.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/button.de33108.css&quot; &#125;&#125; 而资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。 根据业务场景的不同，加载框架可以在浏览器中用JS实现，也可以是后端模板引擎中用服务端语言实现，甚至二者的组合，不一而足。 有关加载框架的具体实现我曾写过很多文章介绍，可以扩展阅读： 前端工程与性能优化 前端工程与模块化框架 这种设计很快被验证具有足够的灵活性，能够完美支撑不同团队不同技术规范下的性能优化需求，前面提到的按需加载、延迟加载、预加载、请求合并、文件指纹、CDN部署、Bigpipe、Quickling、BigRender、首屏CSS内嵌、HTTP 2.0服务端推送等等性能优化手段都可以很容易的在这种架构上实现，甚至可以根据性能日志自动进行优化（Facebook已实现）。 因为有了资源表，我们可以很方便的控制资源加载，通过各种手段在运行时计算页面的资源使用情况，从而获得最佳加载性能。无论是前端渲染的单页面应用，还是后端渲染的多页面应用，这种方法都同样适用。 此外，它还很巧妙的约束了构建工具的职责——只生成资源表。资源表是非常通用的数据结构，无论什么业务场景，其业务代码最终都可以被扫描为相同结构的表数据，并标记资源间的依赖关系，有了表之后我们只需根据不同的业务场景定制不同的资源加载框架就行了，从此彻底告别一个团队维护一套工具的时代！！！ 恩，如你所见，虽然彻底告别了一个团队一套工具的时代，但似乎又进入了一个团队一套框架的时代。其实还是有差别的，因为框架具有很大的灵活性，而且不那么黑盒，采用框架实现资源管理相比构建更容易调试、定位和升级变更。 深耕静态资源加载框架可以带来许多收益，而且有足够的灵活性和健壮性面向未来的技术变革，这个我们留作后话。 总结回顾一下前面提到过的前端工程三个阶段： 第一阶段：库/框架选型 第二阶段：简单构建优化 第三阶段：JS/CSS模块化开发 现在补充上第四阶段： 第四阶段：组件化开发与资源管理 由于先天缺陷，前端相比其他软件开发，在基础架构上更加迫切的需要组件化开发和资源管理，而解决资源管理的方法其实一点也不复杂： 一个通用的资源表生成工具 + 基于表的资源加载框架 近几年来各种你听到过的各种资源加载优化策略大部分都可以在这样一套基础上实现，而这种优化对于业务来说是完全透明的，不需要重构的性能优化——这不正是我们一直所期盼的吗？正如魏小亮博士所说：我们可以把优秀的人集中起来去优化加载。 如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说： 你好，工程师！","categories":[],"tags":[]},{"title":"","slug":"箭头函数","date":"2019-04-28T14:25:41.116Z","updated":"2019-04-28T12:05:16.036Z","comments":true,"path":"2019/04/28/箭头函数/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/箭头函数/","excerpt":"","text":"ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 为什么叫Arrow Function？因为它的定义用的就是一个箭头： 1x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function： &#39;use strict&#39;; `console.log(‘你的浏览器支持ES6的Arrow Function!’); ` Run 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来： 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 12// SyntaxError:x =&gt; &#123; foo: x &#125; 因为和函数体的{ ... }有语法冲突，所以要改为： 12// ok:x =&gt; (&#123; foo: x &#125;) this箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果： 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj： 123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： 1var that = this; 就不再需要了。 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 123456789var obj = &#123; birth: 1990, getAge: function (year) &#123; var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call(&#123;birth:2000&#125;, year); &#125;&#125;;obj.getAge(2015); // 25 转载自： https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000","categories":[],"tags":[]},{"title":"","slug":"错误处理","date":"2019-04-28T14:25:41.114Z","updated":"2019-04-28T14:23:58.983Z","comments":true,"path":"2019/04/28/错误处理/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/错误处理/","excerpt":"","text":"错误处理在执行JavaScript代码的时候，有些情况下会发生错误。 错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如： 12var s = null;var len = s.length; // TypeError：null变量没有length属性 对于这种错误，要修复程序。 一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。 对于这种错误，我们需要处理它，并可能需要给用户反馈。 错误处理是程序设计时必须要考虑的问题。对于C这样贴近系统底层的语言，错误是通过错误码返回的： 123456int fd = open(&quot;/path/to/file&quot;, O_RDONLY);if (fd == -1) &#123; printf(&quot;Error when open file!&quot;);&#125; else &#123; // TODO&#125; 通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的open()函数约定返回-1表示错误。 显然，这种用错误码表示错误在编写程序时十分不便。 因此，高级语言通常都提供了更抽象的错误处理逻辑try … catch … finally，JavaScript也不例外。 try … catch … finally使用try … catch … finally处理错误时，我们编写的代码如下： &#39;use strict&#39;; `// 直接运行` 1234567891011var r1, r2, s = null;try &#123; r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行&#125; catch (e) &#123; console.log('出错了：' + e);&#125; finally &#123; console.log('finally');&#125;console.log('r1 = ' + r1); // r1应为undefinedconsole.log('r2 = ' + r2); // r2应为undefined 1234出错了：TypeError: Cannot read property 'length' of nullfinallyr1 = undefinedr2 = undefined 运行后可以发现，输出提示类似“出错了：TypeError: Cannot read property ‘length’ of null”。 我们来分析一下使用try … catch … finally的执行流程。 当代码块被try { ... }包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到catch块。catch (e) { ... }包裹的代码就是错误处理代码，变量e表示捕获到的错误。最后，无论有没有错误，finally一定会被执行。 所以，有错误发生时，执行流程像这样： 先执行try { ... }的代码； 执行到出错的语句时，后续语句不再继续执行，转而执行catch (e) { ... }代码； 最后执行finally { ... }代码。 而没有错误发生时，执行流程像这样： 先执行try { ... }的代码； 因为没有出错，catch (e) { ... }代码不会被执行； 最后执行finally { ... }代码。 最后请注意，catch和finally可以不必都出现。也就是说，try语句一共有三种形式： 完整的try … catch … finally： 1234567try &#123; ...&#125; catch (e) &#123; ...&#125; finally &#123; ...&#125; 只有try … catch，没有finally： 12345try &#123; ...&#125; catch (e) &#123; ...&#125; 只有try … finally，没有catch： 12345try &#123; ...&#125; finally &#123; ...&#125; 错误类型JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象： 1234567891011try &#123; ...&#125; catch (e) &#123; if (e instanceof TypeError) &#123; alert(&apos;Type error!&apos;); &#125; else if (e instanceof Error) &#123; alert(e.message); &#125; else &#123; alert(&apos;Error: &apos; + e); &#125;&#125; 使用变量e是一个习惯用法，也可以以其他变量名命名，如catch(ex)。 抛出错误程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。 例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用parseInt()转换为整数。当用户输入不合法的时候，我们就抛出错误： &#39;use strict&#39;; `// 直接运行 ` Run 12345678910111213var r, n, s;try &#123; s = prompt('请输入一个数字'); n = parseInt(s); if (isNaN(n)) &#123; throw new Error('输入错误'); &#125; // 计算平方: r = n * n; console.log(n + ' * ' + n + ' = ' + r);&#125; catch (e) &#123; console.log('出错了：' + e);&#125; 1出错了：Error: 输入错误 实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。 最后，当我们用catch捕获错误时，一定要编写错误处理语句： 1234567var n = 0, s;try &#123; n = s.length;&#125; catch (e) &#123; console.log(e);&#125;console.log(n); 哪怕仅仅把错误打印出来，也不要什么也不干： 123456var n = 0, s;try &#123; n = s.length;&#125; catch (e) &#123;&#125;console.log(n); 因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。 处理错误时，请不要简单粗暴地用alert()把错误显示给用户。教程的代码使用alert()是为了便于演示。 异步错误处理：编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。 例如，setTimeout()函数可以传入回调函数，并在指定若干毫秒后执行： 123456function printTime() &#123; console.log(&apos;It is time!&apos;);&#125;setTimeout(printTime, 1000);console.log(&apos;done&apos;); 上面的代码会先打印done，1秒后才会打印It is time!。 如果printTime()函数内部发生了错误，我们试图用try包裹setTimeout()是无效的： 123456789101112function printTime() &#123; throw new Error();&#125;try &#123; setTimeout(printTime, 1000); console.log('done');&#125; catch (e) &#123; console.log('error');&#125;//done 原因就在于调用setTimeout()函数时，传入的printTime函数并未立刻执行！紧接着，JavaScript引擎会继续执行console.log(&#39;done&#39;);语句，而此时并没有错误发生。直到1秒钟后，执行printTime函数时才发生错误，但此时除了在printTime函数内部捕获错误外，外层代码并无法捕获。 所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。 类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。 例如，针对以下的表单： 1234&lt;form&gt; &lt;input id=\"x\"&gt; + &lt;input id=\"y\"&gt; &lt;button id=\"calc\" type=\"button\"&gt;计算&lt;/button&gt;&lt;/form&gt; 1234567891011121314151617try &#123; $btn.click(function () &#123; var x = parseFloat($('#x').val()), y = parseFloat($('#y').val()), r; if (isNaN(x) || isNaN(y)) &#123; throw new Error('输入有误'); &#125; r = x + y; alert('计算结果：' + r); &#125;);&#125; catch (e) &#123; alert('输入有误！');&#125;// 我们用下面的代码给button绑定click事件： 1234567891011121314151617'use strict'; var $btn = $('#calc'); // 取消已绑定的事件: $btn.off('click'); try &#123; $btn.click(function () &#123; var x = parseFloat($('#x').val()), y = parseFloat($('#y').val()), r; if (isNaN(x) || isNaN(y)) &#123; throw new Error('输入有误'); &#125; r = x + y; alert('计算结果：' + r); &#125;);&#125; catch (e) &#123; alert('输入有误！');&#125; 错误传播如果代码发生了错误，又没有被try … catch捕获，那么，程序执行流程会跳转到哪呢？ 12345678910function getLength(s) &#123; return s.length;&#125;function printLength() &#123; console.log(getLength(&apos;abc&apos;)); // 3 console.log(getLength(null)); // Error!&#125;printLength(); 如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽： &#39;use strict&#39;; `// 直接运行，观察控制台输出 ` Run 1234567891011121314151617181920212223function main(s) &#123; console.log('BEGIN main()'); try &#123; foo(s); &#125; catch (e) &#123; console.log('出错了：' + e); &#125; console.log('END main()');&#125;function foo(s) &#123; console.log('BEGIN foo()'); bar(s); console.log('END foo()');&#125;function bar(s) &#123; console.log('BEGIN bar()'); console.log('length = ' + s.length); console.log('END bar()');&#125;main(null); 12345BEGIN main()BEGIN foo()BEGIN bar()出错了：TypeError: Cannot read property 'length' of nullEND main() 当bar()函数传入参数null时，代码会报错，错误会向上抛给调用方foo()函数，foo()函数没有try … catch语句，所以错误继续向上抛给调用方main()函数，main()函数有try … catch语句，所以错误最终在main()函数被处理了。 至于在哪些地方捕获错误比较合适，需要视情况而定。","categories":[],"tags":[]},{"title":"","slug":"变量、作用域与内存问题","date":"2019-04-28T14:25:41.111Z","updated":"2019-04-28T14:02:44.543Z","comments":true,"path":"2019/04/28/变量、作用域与内存问题/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/变量、作用域与内存问题/","excerpt":"","text":"4.1基本类型和引用类型的值ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 数据类型: 基本类型值：Undefined、Null、Boolean、Number、String； 引用类型值，也就是对象类型：Object、Array、Function、Date等； 声明变量时不同的内存分配 基本类型值：存储在栈（stack）中的简单数据段，它们的值直接存储在变量访问的位置。这是因为这些基本类型占据的空间是固定的，所以可以将它们存储在较小的内存区域- 栈中。这样存储更便于迅速查寻变量的值。 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 不同的内存分配机制也带来了不同的访问机制 在javascript中是不允许直接访问保存在堆内存中的对象的，也就是说不能直接操作对象的内存空间。所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。 注意：当复制保存着对象的某个变量时，操作的事对象的引用。但在为对象添加属性时，操作的是实际的对象 复制变量的不同 基础类型值：在将一个保存着基础类型值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count); //20 没有变化console.log(result); //30 引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了） 123456function setName(obj) &#123; obj.name = &quot;Nicholas&quot;;&#125;var person = new Object();setName(person);console.log(person.name); //&quot;Nicholas&quot; 参数传递的不同首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到基础类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。 基础类型值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 引用类型值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧： 所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！来看下面这个例子吧：（传说中的call by sharing） 12345678910111213141516171819var obj1 = &#123; value:&apos;111&apos;&#125;; var obj2 = &#123; value:&apos;222&apos;&#125;; function changeStuff(obj)&#123; obj.value = &apos;333&apos;; obj = obj2; return obj.value;&#125; var foo = changeStuff(obj1); console.log(foo);// &apos;222&apos; 参数obj指向了新的对象obj2console.log(obj1.value);//&apos;333&apos; obj1仍然指向原来的对象,之所以value改变了,是因为changeStuff里的第一条语句，这个时候obj是指向obj1的 .再啰嗦一句，如果是按引用传递的话，这个时候obj1.value应该是等于&#39;222&#39;的 可以把ECMAScript函数的参数想象成局部变量 4.1.4 检测类型如果变量的值是一个对象或null，则typeof操作符会返回&quot;object&quot;. 通常我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符； 如果对象是给定引用类型的实例，那么instanceof操作符就会返回true。 123console.log(person instanceof Object); //变量person是Object吗？console.log(colors instanceof Array); //变量colors是Array吗？console.log(pattern instanceof RegExp); //变量pattern是RegExp吗? 根据规定，所有引用类型的值都是Object的实例。在检查一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。 4.2执行坏境和作用域每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。 每个环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它 当代码在一个环境执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问 4.2.1 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。 try-catch 语句中的 catch 块 with 语句 对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 123456789101112131415var oMyself = &#123; sFirstname: &quot;Aidan&quot;, sLastName: &quot;Dai&quot;&#125;function create()&#123; var sLastName = &quot;Wen&quot; with(oMyself)&#123; //将oMyself作为自己的执行环境 sAllName = sFirstname +&quot; &quot; + sLastName; &#125; return sAllName;&#125;var sMyName = create();console.log(sMyName); //Aidan Dai 4.2.2 没有块级作用域对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。 1. 声明变量使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近环境的就是函数的局部环境；在with语句中，最接近的环境就是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。 注意：在编写JavaScript中，不声明而直接初始化变量时一个错误的做法，因为这样可能会导致意外。在严格模式下，初始化未经声明的变量会导致错误。 2.查询标识符搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境找到，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域向上搜索。搜索过程将一直追溯到全局环境的变量对象。在全局环境也没找到的话则说明该变量尚未声明。 1234567var color = &quot;blue&quot;;function getColor() &#123; return color;&#125;console.log(getColor()); //&quot;blue&quot;; 4.3 垃圾收集JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 变量生命周期 什么叫不再使用的变量？不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包中由于内部函数的原因，外部函数并不能算是结束 一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。貌似很简单的工作，为什么会有很大开销呢？这仅仅是垃圾回收的冰山一角，就像刚刚提到的闭包，貌似函数结束了，其实还没有，垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用的策略有很多，常见的有两种方式 4.3.1 标记清除这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 4.3.2 引用计数在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 4.3.3 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。 事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议这样做。在IE中调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。 4.3.4管理内存确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要数据。一旦数据不再可用，最好通过将其值设置为null来释放其引用——这个方法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象属性。局部变量会在它们离开执行环境时自动被解除引用。 12345678910function createPerson(name) &#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson(&quot;Nicholas&quot;);//手工解除globalPerson的引用globalPerson = null; 4.4 小结基本类型值和引用类型值具有以下特点: 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值得变量实际上包含的并不是对象本身，而是指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 https://segmentfault.com/a/1190000008929249#articleHeader0","categories":[],"tags":[]},{"title":"","slug":"闭包","date":"2019-04-28T14:25:41.108Z","updated":"2019-04-28T12:05:19.502Z","comments":true,"path":"2019/04/28/闭包/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/闭包/","excerpt":"","text":"​ 闭包是指有权访问另一个函数作用域中的变量的函数；常见方式就是在一个函数内部创建另一个函数。 ​ JavaScript 闭包的本质源自两点，词法作用域和函数当作值传递。 词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。 引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。 ​ 通俗地讲就是别人家有某个东西，你想拿到但是因为权限不够（不打死你才怪），但是你可以跟家里的孩子套近乎，通过他拿到！这个家就是局部作用域，外部无法访问内部变量，孩子是返回对象，对家里的东西有访问权限，借助返回对象间接访问内部变量！ 例子： 12345678910function makeFunc() &#123; var name = \"Mozilla\"; function displayName() &#123; alert(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); ​ JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 ​ 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。","categories":[],"tags":[]},{"title":"","slug":"Untitled","date":"2019-04-28T14:25:41.106Z","updated":"2019-04-28T13:45:59.974Z","comments":true,"path":"2019/04/28/Untitled/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"this指针","date":"2019-04-28T14:25:41.104Z","updated":"2019-04-28T12:10:12.671Z","comments":true,"path":"2019/04/28/this指针/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/this指针/","excerpt":"","text":"123A this value is a special object which is related with the execution context. Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated).this适合执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象[context object](激活执行上下文的上下文)。 任何对象都可以作为上下文的this值。我想再次澄清对与ECMAScript中，与执行上下文相关的一些描述——特别是this的误解。通常，this 被错误地，描述为变量对象的属性。最近比如在这本书中就发现了(尽管书中提及this的那一章还不错)。 请牢记： 12a this value is a property of the execution context, but not a property of the variable object.this是执行上下文环境的一个属性，而不是某个变量对象的属性 这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this,这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决中进入上下文时的情况。 顺便说一句，和ECMAScript不同，Python有一个self的参数，和this的情况差不多，但是可以在执行过程中被改变。在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。 在global context(全局上下文)中，this的值就是指全局这个对象，这就意味着，this值就是这个变量本身。 1234567var x = 10; console.log( x, // 10 this.x, // 10 window.x // 10); 在函数上下文[function context]中，this会可能会根据每次的函数调用而成为不同的值.this会由每一次caller提供,caller是通过调用表达式[call expression]产生的（也就是这个函数如何被激活调用的）。例如，下面的例子中foo就是一个callee，在全局上下文中被激活。下面的例子就表明了不同的caller引起this的不同。 1234567891011121314151617181920212223242526// &quot;foo&quot;函数里的alert没有改变// 但每次激活调用的时候this是不同的 function foo() &#123; alert(this);&#125; // caller 激活 &quot;foo&quot;这个callee，// 并且提供&quot;this&quot;给这个 callee foo(); // 全局对象foo.prototype.constructor(); // foo.prototype var bar = &#123; baz: foo&#125;; bar.baz(); // bar (bar.baz)(); // also bar(bar.baz = bar.baz)(); // 这是一个全局对象(bar.baz, bar.baz)(); // 也是全局对象(false || bar.baz)(); // 也是全局对象 var otherFoo = bar.baz;otherFoo(); // 还是全局对象 如果要深入思考每一次函数调用中，this值的变化(更重要的是怎样变化)，你可以阅读本系列教程第10章This。上文所提及的情况都会在此章内详细讨论。","categories":[],"tags":[]},{"title":"","slug":"promise","date":"2019-04-28T14:25:41.101Z","updated":"2019-04-28T10:21:21.514Z","comments":true,"path":"2019/04/28/promise/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/promise/","excerpt":"","text":"-– title: Promise探析 date: 2019-04-26 categories: First #分类 author: along tags: #标签 ​ - Promise thumbnail: https://xxxxxxxxxx.png # 略缩图 cover_picture: /images/banner.jpg -– 前言 上一篇，关于axios的二次封装，我们已经探讨过什么是Promise，它可以做什么的问题，现在，我们继续来通过一个简单的DOM案例探析。 你还在这样写？DOM原生事件 根据MDN上面的相关推荐指导，我们应该更多地去使用addEventListener，而非那些原生定义的onclick之类的。 1234567891011//比如我们尝试去添加一个动画效果 window.onload = () =&gt; &#123; document.querySelector(&apos;.app1&apos;) .addEventListener(&apos;mouseenter&apos;, (event) =&gt; &#123; const timer = setInterval(()=&gt;&#123; event.style.opacity += 0.1; if (event.style.opacity === 1) clearInterval(timer); &#125;,1000/20) &#125;); &#125; 我的天呐！一层、两层……总共三层回调，这已经调入回调地狱了，如果再深入设置其他的动画，那岂不是更乱了，想想办法吧。 jQuery写法123456789101112$(()=&gt;&#123; $(&apos;.app&apos;).hover(function(e)=&gt;&#123; const timer = setInterval(()=&gt;&#123; e.css(&#123; opacity:`++0.1` &#125;) if (e.css(&apos;opacity&apos;) === 1) clearInterval(timer); &#125;,1000/20) &#125;); &#125;);&#125;) 一样的酸爽对吧！ 这样做才爽Demo JS部分 1234567891011121314151617181920212223242526272829303132333435363738window.onload = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; document.querySelector(&apos;.app1&apos;) .addEventListener(&apos;mouseenter&apos;, () =&gt; &#123; resolve(&apos;Test&apos;); &#125;); &#125;) .then((data) =&gt; &#123; console.log(data); if (data) &#123; let height = getComputedStyle(document.querySelector(&apos;.app2&apos;))[&apos;top&apos;]; let value = Number.parseInt(height); let timer = setInterval(() =&gt; &#123; value += 10; console.log(value); document.querySelector(&apos;.app2&apos;) .style.top = `-$&#123;value&#125;px`; if (value === 200) &#123; clearInterval(timer); &#125; &#125;, 1000 / 20); &#125; return true; &#125;, (err) =&gt; &#123; console.log(err); &#125;) .then((data) =&gt; &#123; console.log(data); console.log(&apos;开始执行显示&apos;); if (data) &#123; document.querySelector(&apos;.app2&apos;) .style.display = &apos;block&apos;; document.querySelector(&apos;.app2&apos;) .style.opacity = 0.6; &#125; &#125;) &#125; HTML部分 1234567&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;app1&quot;&gt; &lt;img src=&quot;./logo.png&quot; alt=&quot;logo&quot;&gt; &lt;/div&gt; &lt;div class=&quot;app2&quot;&gt; Vue.js &lt;/div&gt; CSS部分 123456789101112131415161718192021&lt;style&gt; .box&#123; width: 300px; margin: 50px auto; &#125; .app1 &#123; width: 200px; height: 200px; &#125; .app2 &#123; width: 200px; height: 200px; background-color: gainsboro; opacity: 8; display: none; text-align: center; position: relative; top: 0; &#125; &lt;/style&gt; 总结 一个Promise可以有多个then函数衔接处理，达到一个同步处理的效果，每次then之后，下一个then接收的是上一个then的return数据，第一个then则接收的是最初的promise回调resolve放行的数据。 引用自： https://ivu1314.club/categories/%E7%BB%8F%E9%AA%8C/","categories":[],"tags":[]},{"title":"","slug":"JS核心知识归纳(进阶)","date":"2019-04-28T14:25:41.098Z","updated":"2019-04-28T13:58:22.455Z","comments":true,"path":"2019/04/28/JS核心知识归纳(进阶)/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/JS核心知识归纳(进阶)/","excerpt":"","text":"js–进阶1.原型链许多OO语言支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。由于函数无签名，在JavaScript中无法实现接口继承。所以只能实现方法继承。实现继承主要依赖原型链。基本思想：利用原型，让那个一个引用类型继承另一个引用类型的属性和方法。A.prototype= new B();让原型对象等于另一个类型的实例。所有函数的默认原型都是Object的实例即A继承了B ；B 继承了Object; 什么是原型对象。我们知道每个构造函数一旦创建都有prototype指针指向它的原型对象（构造函数.prototype）。而原型对象（构造函数.prototype）会默认生成一个constructor指针又指向构造函数。在创建实例时，每个实例有一个proto指向该原型对象。原型对象内创建的所有方法会被所有实例共享。例： 12345Function.prototype = &#123; constructor : Function, __proto__ : parent prototype, some prototype properties: ... &#125;; 原型对象中的方法属性是被所有实例共享的。如果含有引用类型的属性，如数组，修改person1中的数组属性，也会导致person2中的该属性发生变化。 什么是原型链？函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针proto，该指针指向上一层的原型对象，而上一层的原型对象的结构依然类似，这样利用proto一直指向Object的原型对象上，而Object的原型对象用Object.prototype.proto = null表示原型链的最顶端，如此变形成了javascript的原型链继承，同时也解释了为什么所有的javascript对象都具有Object的基本方法。 原型链就是创建一个构造函数，它会默认生成一个prototype属性并指向原型对象。使用下一个构造函数的原型对象作为这个构造函数的实例。即 A.prototype = new B(); 在下下一个构造函数的原型对象 = new nextFuction。这样下去就会构成一条实例与原型之间的链条，这就是原型链。 2.继承构造函数A()和实例a1 a2之间的关系；var a1 = new A(); var a2 = new A();实例a1与实例a2是独立的实例和原型的关系 a1.proto = A.prototype构造函数A()和其原型的关系 A.prototype.constructor=A 6种继承方式原型链继承本质:是子用类型B的原型等于超类型的实例,B.prototype= new A() 构造函数继承本质:是子用类型的构造函数内部调用A(),B(){A.call(this,**);} 组合继承本质原型链和构造函数的组合，原型继承方法，构造函数继承属性 原型式继承本质:基于已有对象创建一个对象,即对象A的浅拷贝,var b= Object.create(A) 寄生式继承本质:创建一个用于封装继承过程的函数,function b(A){var clone = Object.create(A) ;clone.=;return clone;} 寄生组合继承本质:寄生式继承超类型A的原型,并将结果赋值给子类型的原型;或对对象A的原型浅拷贝，function B(**){ 1A.call(this,**) }function c(A,B){var clone = Object.create(A.prototype); clone.constructor = B;B.prototype=clone;) ;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 function Person(name) &#123; this.name = [&apos;123&apos;,&apos;456&apos;,&apos;789&apos;,name]; &#125; Person.prototype.go = function()&#123; return console.log(this.name) &#125; Person.prototype.sex = [&apos;男&apos;,&apos;女&apos;]; var ren = new Person(); console.log(&apos;构造函数和原型的关系:&apos;,Person.prototype.constructor ===Person) console.log(&apos;实例和原型的关系&apos;,ren.__proto__ ===Person.prototype) // 原型链继承 // 缺点1.不能向person中传递参数； // 缺点2.超类型的原型属性会被其他实例共享，一个实例改变，则其他实例也改变。 // 下面2个原型的顺序不能换 function Shuagnfeng(love) &#123; this.love = [&apos;fd&apos;,&apos;fddfdf&apos;]; &#125; Shuagnfeng.prototype = new Person(); console.log(&apos;会误会超类型Person:&apos;,Shuagnfeng.prototype.constructor ===Person) //true console.log(&apos;构成原型链,&apos;,Shuagnfeng.prototype.__proto__ ===Person.prototype) //true Shuagnfeng.prototype.constructor ===Shuagnfeng; Shuagnfeng.prototype.goWork = function()&#123; return console.log(&apos;原型链继承的方法&apos;); &#125; var child = new Person();Shuagnfeng.prototype.name.push(121);console.log(&apos;超类型实例2 child&apos;,child.name); var xiaozhang = new Shuagnfeng(&apos;dff&apos;); var xiaozhang1 = new Shuagnfeng(&apos;zzz&apos;); xiaozhang.go(); xiaozhang.goWork(); xiaozhang.name.push(&apos;只对xiaozhang增加属于超类型Person中array值&apos;,22); xiaozhang.love.push(&apos;只对xiaozhang增加属于构造函数中array值&apos;,22); xiaozhang.sex.push(&apos;只对xiaozhang增加属于超类型的原型中array值&apos;); console.log(&apos;xiaozhang.超类型Person中name&apos;,xiaozhang.name); console.log(&apos;xiaozhang1.超类型Person中name&apos;,xiaozhang1.name); console.log(&apos;xiaozhang.构造函数中中love&apos;,xiaozhang.love); console.log(&apos;xiaozhang1.构造函数中love&apos;,xiaozhang1.love); console.log(&apos;xiaozhang.超类型的原型中sex&apos;,xiaozhang.sex); console.log(&apos;xiaozhang1.超类型的原型中sex&apos;,xiaozhang1.sex);// 构造函数的继承// 优点，不会改变引用类型的属性，能传递参数// 缺点无法复用方法； function Jianbo() &#123; Person.call(this,&apos;构造函数的继承&apos;) &#125; var xiaonie = new Jianbo(); console.log(&apos;构造函数的继承xiaonie.name可传参数&apos;,xiaonie.name); // xiaonie.go(); // 不存在// 组合继承// 原型链继承方法、构造函数继承属性 function Nb(love) &#123; Person.call(this,&apos;nb&apos;) this.love = love &#125; Nb.prototype = new Person(&apos;12&apos;); console.log(&apos;12&apos;,Nb.prototype.constructor ===Person) // true console.log(&apos;13&apos;,Nb.prototype.constructor ===Nb)// false 因为重写原型，会使原型失去了constructor属性 Nb.prototype.constructor =Nb console.log(&apos;14&apos;,Nb.prototype.constructor ===Person) // false Nb.prototype.say = function()&#123; console.log(&apos;say&apos;,&apos;say&apos;) &#125; var nb= new Nb(); var nb1= new Nb(&apos;组合继承&apos;); nb.name.push(&apos;xiaoniubi&apos;); console.log(&apos;nb.name&apos;,nb.name); console.log(&apos;nb1.name&apos;,nb1.name); console.log(&apos;nb1.love&apos;,nb1.love); nb.go(); nb.say();// 原型式继承Object.create() 将基础对象传给object()函数 // 本质是浅复制 副本的引用类型会被改变// 缺点：引用类型的属性会被共享 和原型链继承差不多// 使用场景： 让一个对象与另一个对象的保持类似function object(o)&#123; function F()&#123;&#125; F.prototype= o; return new F();&#125;var animal = &#123; name:&apos;原型式继承默认值&apos;, friends:[1,2,3,4]&#125;var haha= object(animal);var gaga = Object.create(animal);var haha1= object(animal);console.log(&apos;haha&apos;,haha.name);console.log(&apos;gaga&apos;,gaga.name);haha.name=&apos;原型式继承name值变了&apos;;haha.friends.push(&apos;原型式继承array值变了&apos;);console.log(&apos;haha&apos;,haha.name);console.log(&apos;haha1&apos;,haha1.name);console.log(&apos;haha&apos;,haha.friends);console.log(&apos;haha1&apos;,haha1.friends);// 寄生式继承// 能继承方法，但方法不能复用function createAnother(original)&#123; var clone = object(original); clone.say = function()&#123; console.log(&apos;寄生式继承方法&apos;) &#125; return clone;&#125;var hh = createAnother(animal);hh.name=&apos;寄生式继承&apos;console.log(&apos;hh&apos;,hh.name);hh.say() // 寄生组合式// 所有方式中最有效的方式 只调用继承的构造函数一次// 判断实例和原型的关系 使用instanceof 和 isPrototypeOf() console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Shuagnfeng); console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Person); console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Object); console.log(&apos;实例和原型的关系&apos;,Object.prototype.isPrototypeOf(xiaozhang)); console.log(xiaozhang.__proto__); 3.事件委托事件处理程序 获取事件对象 事件目标好处 减少DOM 操作 ，减少性能 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;list&quot;&gt; &lt;img id=&quot;1&quot; src=&quot;1.png&quot;&gt; &lt;img id=&quot;3.2.2&quot; src=&quot;3.2.2.png&quot;&gt; &lt;img id=&quot;3.2&quot; src=&quot;3.2.png&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var EventUtil = &#123; addHandler: function(element,type,handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type,handler,false) &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler:function(element,type,handler) &#123; if(element.removeEventListener) &#123; element.removeEventListener(type,handler,false) &#125; &#125;, getEvent:function(event)&#123; return event ? event : window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, &#125; var list = document.getElementById(&apos;list&apos;) EventUtil.addHandler(list,&apos;click&apos;,function(ev)&#123; event= EventUtil.getEvent(ev); var target = EventUtil.getTarget(event); alert(target.id); &#125;) // list.onclick = function(ev)&#123;// var ev = ev || window.event;// var target = ev.target || ev.srcElement;// console.log(target.id);// &#125; &lt;/script&gt; 4.跨域造成跨域的原因：浏览器的同源策略，即XMLHttpRequest(XHR)对象只能访问同一域中的资源这是种防止恶意行为的安全策略。第二个：浏览器中不同域的框架之间是不能进行js的交互操作的。 何谓同源:URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示它们同源。 在浏览器中，、、、等标签属于DOM， 非XHR对象，是可以加载跨域资源 跨域方法(实践中后两种最常用，所以重点介绍):(1) 通过jsonp跨域ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。(2) 通过修改document.domain来跨子域(3) 使用window.name来进行跨域(4) 使用HTML5中新引进的window.postMessage方法来跨域传送数据(5) 使用代理服务器,使用代理方式跨域更加直接，因为同源限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了。 123456使用本方法跨域步骤如下：1. 把访问其它域的请求替换为本域的请求2. 服务器端的动态脚本负责将本域的请求转发成实际的请求为了通过Ajax从http://localhost:8080访问http://localhost:8081/api，可以将请求发往http://localhost:8080/api。然后利用Apache Web服务器的Reverse Proxy功能做如下配置：ProxyPass /api http://localhost:8081/api (6) CORS全称是”跨域资源共享“（Cross-origin resource sharing),CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能 发送请求时，附加一个额外的Origin头部IE：XDR(XDomainRequest) 创建一个xdr实例，调用open() ,再send()方法；其他的，原生的支持，使用绝对的URL即可。 附：ajax的扩展，comment/Web Sockets(7) fetch api 5.输入url之后，到底发生了什么？ 6 JS引擎浏览器内核又可以分成两部分：渲染引擎(layout engineer或者RenderingEngine)和JS引擎。JS的引擎深入分析链接描述10分钟理解JS引擎的执行机制http://www.ruanyifeng.com/blo…JS引擎负责对JavaScript进行解释、编译和执行，以使网页达到一些动态的效果。 js的几种引入方式；js引擎是单线程 异步的— 任务队列 事件 和回调函数 Event Loop是通过的事件循环(event loop),实现单线程和异步的。单线程：同一时刻只能执行一个代码块将要执行的代码放在任务队列中，但js引擎执行代码块结束，事件循环会执行任务队列中的下一个任务。Event Loop 负责监控代码执行和管理任务队列。异步的，即可通过事件 回调等方式，向任务队列中添加新任务。 JS的执行机制是 首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table异步任务在event table中注册函数,当满足触发条件后,被推入event queue同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中以上三步循环执行,这就是event loop 准确的划分方式是:macro-task(宏任务)：包括整体代码script，setTimeout，setIntervalmicro-task(微任务)：Promise，process.nextTick按照这种分类方式:JS的执行机制是 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完重复以上2步骤,结合event loop(1) event loop(2) ,就是更为准确的JS执行机制了。 7 错误监控前端错误的分类 运行时错误（代码错误） 资源加载错误 接口错误 错误的捕获方式 运行时错误的捕获方式： 1234567try...catchwindow.onerror 含有详细的error信息 window.onerror = function(msg, url, lineNo, columnNo, error)&#123;&#125;window.addEventListener(&apos;error&apos;) window.addEventListener(&apos;error&apos;, event =&gt; &#123; console.log(&apos;addEventListener error:&apos; + event.target); &#125;, true); 资源加载错误： 123object.onerror（如img,script）performance.getEntries()Error事件捕获 接口错误： 12所有http请求都是基于xmlHttpRequest或者fetch封装的。所以要捕获全局的接口错误，方法就是封装xmlHttpRequest或者fetch 结论1.使用window.onerror捕获JS运行时错误2.使用window.addEventListener(‘unhandledrejection’)捕获未处理的promise reject错误3.重写console.error捕获console.error错误4.在跨域脚本上配置crossorigin=”anonymous”捕获跨域脚本错误window.addEventListener(‘error’)捕获资源加载错误。因为它也能捕获js运行时错误，为避免重复上报js运行时错误，此时只有event.srcElement inatanceof HTMLScriptElement或HTMLLinkElement或HTMLImageElement时才上报5.重写window.XMLHttpRequest和window.fetch捕获请求错误 延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？ 1234可以。Script error1.在script标签增加crossorigin属性2.设置js资源响应头Access-Control-Allow-Orgin:* 上报错误的基本原理 121. 采用Ajax通信方式上报2. 利用Image对象上报 https://segmentfault.com/a/1190000014728771#articleHeader19","categories":[],"tags":[]},{"title":"","slug":"generator","date":"2019-04-28T14:25:41.093Z","updated":"2019-04-28T13:46:44.980Z","comments":true,"path":"2019/04/28/generator/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/generator/","excerpt":"","text":"generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补Python教程！。 我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果： 12345function foo(x) &#123; return x + x;&#125;var r = foo(1); // 调用foo函数 函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。 generator跟函数很像，定义如下： 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？ 还是举个栗子吧。 我们以一个著名的斐波那契数列为例，它由0，1开头： 10 1 1 2 3 5 8 13 21 34 ... 要编写一个产生斐波那契数列的函数，可以这么写： 12345678910111213141516function fib(max) &#123; var t, a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) &#123; [a, b] = [b, a + b]; arr.push(b); &#125; return arr;&#125;// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下： 12345678910111213function* fib(max) &#123; var t, a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n ++; &#125; return;&#125; 直接调用试试： 1fib(5); // fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125; 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法： 1234567var f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125; next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done： &#39;use strict&#39; function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return; } Run generator和普通函数相比，有什么用？ 因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写： 12345678910111213141516171819var fib = &#123; a: 0, b: 1, n: 0, max: 5, next: function () &#123; var r = this.a, t = this.a + this.b; this.a = this.b; this.b = t; if (this.n &lt; this.max) &#123; this.n ++; return r; &#125; else &#123; return undefined; &#125; &#125;&#125;; 用对象的属性来保存状态，相当繁琐。 generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。 没有generator之前的黑暗时代，用AJAX时需要这么写代码： 12345678910111213141516ajax(&apos;http://url-1&apos;, data1, function (err, result) &#123; if (err) &#123; return handle(err); &#125; ajax(&apos;http://url-2&apos;, data2, function (err, result) &#123; if (err) &#123; return handle(err); &#125; ajax(&apos;http://url-3&apos;, data3, function (err, result) &#123; if (err) &#123; return handle(err); &#125; return success(result); &#125;); &#125;);&#125;); 回调越多，代码越难看。 有了generator的美好时代，用AJAX时可以这么写： 123456789try &#123; r1 = yield ajax(&apos;http://url-1&apos;, data1); r2 = yield ajax(&apos;http://url-2&apos;, data2); r3 = yield ajax(&apos;http://url-3&apos;, data3); success(r3);&#125;catch (err) &#123; handle(err);&#125; 看上去是同步的代码，实际执行是异步的。","categories":[],"tags":[]},{"title":"","slug":"canvas","date":"2019-04-28T14:25:41.090Z","updated":"2019-04-28T13:56:47.553Z","comments":true,"path":"2019/04/28/canvas/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/28/canvas/","excerpt":"","text":"Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。 一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制： 1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 由于浏览器对HTML5标准支持不一致，所以，通常在&lt;canvas&gt;内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略&lt;canvas&gt;内部的HTML，如果浏览器不支持Canvas，它将显示&lt;canvas&gt;内部的HTML： 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas： 1234&lt;!-- HTML代码 --&gt;&lt;canvas id=&quot;test-canvas&quot; width=&quot;200&quot; heigth=&quot;100&quot;&gt; &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt; getContext(&#39;2d&#39;)方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。 1var ctx = canvas.getContext(&apos;2d&apos;); 如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形： 1gl = canvas.getContext(&quot;webgl&quot;); 本节我们只专注于绘制2D图形。 绘制形状我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统： Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。 CanvasRenderingContext2D对象有若干方法来绘制图形： 12345&apos;use strict&apos;;var canvas = document.getElementById(&apos;test-shape-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); (no output) 绘制文本绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致： 12345&apos;use strict&apos;;var canvas = document.getElementById(&apos;test-text-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); (no output) Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案： 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中； 尽量使用整数坐标而不是浮点数； 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图； 背景图片如果不变可以直接用&lt;img&gt;标签并放到最底层。","categories":[],"tags":[]},{"title":"AJAX","slug":"ajax简介","date":"2019-04-25T16:00:00.000Z","updated":"2019-04-26T00:23:03.512Z","comments":true,"path":"2019/04/26/ajax简介/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/26/ajax简介/","excerpt":"","text":"什么是 AJAX ？AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX = 异步 JavaScript 和 XML。Asynchronous Javascript And XML AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 AJAX - 创建 XMLHttpRequest 对象 XMLHttpRequest 是 AJAX 的基础。 XMLHttpRequest 对象所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest 对象的语法： variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： variable=new ActiveXObject(“Microsoft.XMLHTTP”); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： 兼容语法： var xmlhttp;if (window.XMLHttpRequest){// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码xmlhttp=new XMLHttpRequest();}else{// IE6, IE5 浏览器执行代码xmlhttp=new ActiveXObject(“Microsoft.XMLHTTP”);} AJAX - 向服务器发送请求请求 XMLHttpRequest 对象用于和服务器交换数据。 向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： xmlhttp.open(“GET”,”ajax_info.txt”,true); xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求一个简单的 GET 请求： 实例xmlhttp.open(“GET”,”/try/ajax/demo_get.php”,true); xmlhttp.send(); POST 请求一个简单 POST 请求： 实例 xmlhttp.open(“POST”,”/try/ajax/demo_post.php”,true); xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： 实例 xmlhttp.open(“POST”,”/try/ajax/demo_post2.php”,true); xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”); xmlhttp.send(“fname=Henry&amp;lname=Ford”); 方法 描述 setRequestHeader(header,value) 向请求添加 HTTP 头。 header: 规定头的名称 value: 规定头的值 url - 服务器上的文件open() 方法的 url 参数是服务器上文件的地址： xmlhttp.open(“GET”,”ajax_test.html”,true); 该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true： xmlhttp.open(“GET”,”ajax_test.html”,true); 对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。 通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 Async=true当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数： sync = false如需使用 async=false，请将 open() 方法中的第三个参数改为 false： 1xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false); 我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可： AJAX - 服务器 响应 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 responseText 属性如果来自服务器的响应并非 XML，请使用 responseText 属性。 responseText 属性返回字符串形式的响应，因此您可以这样使用： document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： ​ 实例请求 cd_catalog.xml 文件，并解析响应： xmlDoc=xmlhttp.responseXML; txt=””; x=xmlDoc.getElementsByTagName(“ARTIST”); for (i=0;i&lt;x.length;i++) { txt=txt + x[i].childNodes[0].nodeValue + ““; } document.getElementById(“myDiv”).innerHTML=txt; 获取元素内容 /txt=txt + x[i].childNodes[0].nodeValue + “ “; AJAX - onreadystatechange 事件 onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 实例 xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText; } } 注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。 ps： xmlhttp.readyState的值及解释： 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 xmlhttp.status的值及解释： 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 200——交易成功 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 300——请求的资源可在多处得到 301——删除请求数据 302——在其他地址发现了请求数据 303——建议客户访问其他URL或访问方式 304——客户端已经执行了GET，但文件未变化 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 400——错误请求，如语法错误 401——请求授权失败 402——保留有效ChargeTo头响应 403——请求不允许 404——没有发现文件、查询或URl 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求 合起来 500——服务器产生内部错误 501——服务器不支持请求的函数 502——服务器暂时不可用，有时是为了防止发生系统过载 503——服务器过载或暂停维修 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长 505——服务器不支持或拒绝支请求头中指定的HTTP版本 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200的解释：请求完成并且成功返回","categories":[{"name":"First","slug":"First","permalink":"https://wll-1017065322.github.io/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"https://wll-1017065322.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"https://wll-1017065322.github.io/tags/Second/"}],"author":"MinHow"},{"title":"Hello World","slug":"hello-world","date":"2019-04-25T15:58:38.687Z","updated":"2019-04-25T15:58:38.687Z","comments":true,"path":"2019/04/25/hello-world/","link":"","permalink":"https://wll-1017065322.github.io/2019/04/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test_my_site","slug":"test-my-site","date":"2019-03-27T06:36:42.000Z","updated":"2019-04-25T15:58:38.690Z","comments":true,"path":"2019/03/27/test-my-site/","link":"","permalink":"https://wll-1017065322.github.io/2019/03/27/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello World","date":"2017-06-17T16:00:00.000Z","updated":"2019-04-25T15:58:38.685Z","comments":true,"path":"2017/06/18/Hello World/","link":"","permalink":"https://wll-1017065322.github.io/2017/06/18/Hello World/","excerpt":"MinHow-This is a summary","text":"MinHow-This is a summary","categories":[{"name":"First","slug":"First","permalink":"https://wll-1017065322.github.io/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"https://wll-1017065322.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"https://wll-1017065322.github.io/tags/Second/"}],"author":"MinHow"},{"title":"hexo 的第一篇文章","slug":"hexo 的第一篇文章","date":"2017-03-27T05:48:25.000Z","updated":"2019-04-25T15:58:38.689Z","comments":true,"path":"2017/03/27/hexo 的第一篇文章/","link":"","permalink":"https://wll-1017065322.github.io/2017/03/27/hexo 的第一篇文章/","excerpt":"","text":"hexo 的第一篇文章","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://wll-1017065322.github.io/categories/Algorithm/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://wll-1017065322.github.io/tags/标签1/"},{"name":"标签2 (可选)","slug":"标签2-可选","permalink":"https://wll-1017065322.github.io/tags/标签2-可选/"}]}]}