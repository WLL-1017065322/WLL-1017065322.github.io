{"meta":{"title":"阿龙的小型博客","subtitle":null,"description":null,"author":"wang lv long","url":"https://WLL-1017065322.github.io","root":"/"},"pages":[{"title":"简历","date":"2019-05-12T03:46:35.939Z","updated":"2019-05-12T03:46:35.939Z","comments":true,"path":"about/index.html","permalink":"https://WLL-1017065322.github.io/about/index.html","excerpt":"","text":"💘个人信息 姓名：王履龙 性别：男 兴趣爱好：热爱编程，热爱读书。 座右铭：我距离梦想只差一个坚持，在路上，正如茅盾一样，从来不梦想，只想认清现实。 💪技能素养 ☺擅长skills 熟悉HTML5与CSS3，网页常规布局有一定的实践经验 熟悉Vue，jQuery，BootStrap等前端框架的使用 熟悉JavaScript，对于ES6/7/8特性较为熟悉，熟悉OOP编程与JS模块化开发 熟悉webpack前端自动化构建工具 熟悉Node.js与Express框架的使用 熟悉前后端分离开发的流程，有过前端双模式解决跨域请求的开发经验 熟悉git分布式版本控制系统 😟短板skills 网站SEO Linux操作系统 Nuxt服务端渲染 react/angluar 数据库（Mysql，nosql） 🔰项目展示 📕常用框架锦集 BootStrap jQuery LayUi Vue iview BootStrap-Vue Element-UI mint vant 📃GitHub生涯 传送门 📃500丁正式简历 简历链接 🔨人生目标 全栈工程师 📝个人感悟 学习一途有太多的坎坷，尽管很艰苦，但是慢慢地爬完了那些所谓的坑，倒也觉得自己强大了不少，在任何知识面前，我们都是热衷的追求者，理应当抱着一种求知的态度去探索。坚持自己一开始的信仰，我们一定会步入成功的路途，不抛弃，不放弃！"},{"title":"Gallery","date":"2017-01-17T13:39:03.000Z","updated":"2019-05-12T03:46:36.020Z","comments":true,"path":"gallery/index.html","permalink":"https://WLL-1017065322.github.io/gallery/index.html","excerpt":"","text":"图库"},{"title":"group","date":"2017-01-17T13:05:04.000Z","updated":"2019-05-12T03:46:36.026Z","comments":true,"path":"group/index.html","permalink":"https://WLL-1017065322.github.io/group/index.html","excerpt":"","text":"团队"},{"title":"tags","date":"2017-01-17T13:39:14.000Z","updated":"2019-05-12T03:46:36.031Z","comments":true,"path":"tag/index.html","permalink":"https://WLL-1017065322.github.io/tag/index.html","excerpt":"","text":"tags"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-05-12T03:46:35.915Z","updated":"2019-05-12T03:46:35.915Z","comments":true,"path":"2019/05/12/hello-world/","link":"","permalink":"https://WLL-1017065322.github.io/2019/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"AJAX","slug":"ajax简介","date":"2019-04-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.830Z","comments":true,"path":"2019/04/26/ajax简介/","link":"","permalink":"https://WLL-1017065322.github.io/2019/04/26/ajax简介/","excerpt":"","text":"什么是 AJAX ？AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX = 异步 JavaScript 和 XML。Asynchronous Javascript And XML AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 AJAX - 创建 XMLHttpRequest 对象 XMLHttpRequest 是 AJAX 的基础。 XMLHttpRequest 对象所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest 对象的语法： variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： variable=new ActiveXObject(“Microsoft.XMLHTTP”); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： 兼容语法： var xmlhttp;if (window.XMLHttpRequest){// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码xmlhttp=new XMLHttpRequest();}else{// IE6, IE5 浏览器执行代码xmlhttp=new ActiveXObject(“Microsoft.XMLHTTP”);} AJAX - 向服务器发送请求请求 XMLHttpRequest 对象用于和服务器交换数据。 向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： xmlhttp.open(“GET”,”ajax_info.txt”,true); xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求一个简单的 GET 请求： 实例xmlhttp.open(“GET”,”/try/ajax/demo_get.php”,true); xmlhttp.send(); POST 请求一个简单 POST 请求： 实例 xmlhttp.open(“POST”,”/try/ajax/demo_post.php”,true); xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： 实例 xmlhttp.open(“POST”,”/try/ajax/demo_post2.php”,true); xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”); xmlhttp.send(“fname=Henry&amp;lname=Ford”); 方法 描述 setRequestHeader(header,value) 向请求添加 HTTP 头。 header: 规定头的名称 value: 规定头的值 url - 服务器上的文件open() 方法的 url 参数是服务器上文件的地址： xmlhttp.open(“GET”,”ajax_test.html”,true); 该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true： xmlhttp.open(“GET”,”ajax_test.html”,true); 对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。 通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 Async=true当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数： sync = false如需使用 async=false，请将 open() 方法中的第三个参数改为 false： 1xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false); 我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可： AJAX - 服务器 响应 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 responseText 属性如果来自服务器的响应并非 XML，请使用 responseText 属性。 responseText 属性返回字符串形式的响应，因此您可以这样使用： document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： ​ 实例请求 cd_catalog.xml 文件，并解析响应： xmlDoc=xmlhttp.responseXML; txt=””; x=xmlDoc.getElementsByTagName(“ARTIST”); for (i=0;i&lt;x.length;i++) { txt=txt + x[i].childNodes[0].nodeValue + ““; } document.getElementById(“myDiv”).innerHTML=txt; 获取元素内容 /txt=txt + x[i].childNodes[0].nodeValue + “ “; AJAX - onreadystatechange 事件 onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 实例 xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText; } } 注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。 ps： xmlhttp.readyState的值及解释： 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 xmlhttp.status的值及解释： 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 200——交易成功 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 300——请求的资源可在多处得到 301——删除请求数据 302——在其他地址发现了请求数据 303——建议客户访问其他URL或访问方式 304——客户端已经执行了GET，但文件未变化 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 400——错误请求，如语法错误 401——请求授权失败 402——保留有效ChargeTo头响应 403——请求不允许 404——没有发现文件、查询或URl 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求 合起来 500——服务器产生内部错误 501——服务器不支持请求的函数 502——服务器暂时不可用，有时是为了防止发生系统过载 503——服务器过载或暂停维修 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长 505——服务器不支持或拒绝支请求头中指定的HTTP版本 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200的解释：请求完成并且成功返回","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"alone"},{"title":"12种不宜使用的Javascript语法","slug":"12种不宜使用的Javascript语法","date":"2019-04-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.827Z","comments":true,"path":"2019/04/26/12种不宜使用的Javascript语法/","link":"","permalink":"https://WLL-1017065322.github.io/2019/04/26/12种不宜使用的Javascript语法/","excerpt":"","text":"​ 该书的作者是Douglas Crockford，他是目前世界上最精通Javascript的人之一，也是Json格式的创造者。 ​ 他认为Javascript有很多糟粕。因为1995年Brendan Eich设计这种语言的时候，只用了三个月，很多语言特性没有经过深思熟虑，就推向了市场。结果等到人们意识到这些问题的时候，已经有100万程序员在使用它了，不可能再大幅修改语言本身了。所以，Douglas Crockford决定，他要告诉大家，Javascript中哪些部分是精粹，哪些部分是糟粕和鸡肋。 ​ 这个想法非常好，但是我不得不说，这本书写得不够好，不适合新手阅读。原因如下：1）Douglas Crockford叙述得不清晰，更像与同行讨论问题，而不是由浅入深地讲解问题。这本书的重点不是解释，所以读完后，我觉得Javascript好像变得更复杂了。2）他固执地使用铁路图（railroad diagram）解释每一条语句。全世界似乎只有他一个人使用这种比Javascript更难看懂的图。3）该书基本上是一本简化的Javascript语法手册，缺乏足够的新内容。4）该书举例过少，而且在最难的函数和对象部分，使用的例子都是环环相套、层层递进的例子，导致阅读起来很吃力。 ​ 该书最有价值的内容不是正文，反而是附录。在附录B中，Douglas Crockford列出了12种应该避免使用的Javascript语法，我觉得非常值得推广。 ============================== 1. ==​ Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。 ​ 请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false： false == ‘false’ false == undefined false == null null == undefined 0 == ‘’ 前三个是false，后两个是true。 2. withwith的本意是减少键盘输入。比如 obj.a = obj.b; obj.c = obj.d; 可以简写成 with(obj) { a = b; c = d; } 但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。 3. eval### eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。 eval能够做到的事情，不用它也能做到。比如 eval(“myValue = myObject.” + myKey + “;”); 可以直接写成 myValue = myObject[myKey]; 至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行。 4. continue这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。 5. switch 贯穿switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如 switch(n) { case 1: case 2: break; } 这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。 switch(n) { case 1: break; case 2: break; } 6. 单行的块结构if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如 if (ok) t = true; 甚至写成 if (ok) t = true; 这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。 if (ok){ t = true; } 7. ++和–递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。 8. 位运算符Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。 这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。 9. function语句在Javascript中定义一个函数，有两种写法： function foo() { } 和 var foo = function () { } 两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。 10. 基本数据类型的包装对象Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值： new String(“Hello World”); new Number(2000); new Boolean(false); 这样写完全没有必要，而且非常费解，因此建议不要使用。 另外，new Object和new Array也不建议使用，可以用{}和[]代替。 11. new语句Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。 类是这样定义的： var Cat = function (name) { this.name = name; this.saying = ‘meow’ ; } 然后，再生成一个对象 var myCat = new Cat(‘mimi’); 这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。 Douglas Crockford给出了一个函数： Object.beget = function (o) { var F = function (o) {}; F.prototype = o ; return new F; }; 创建对象时就利用这个函数，对原型对象进行操作： var Cat = { name:’’, saying:’meow’ }; var myCat = Object.beget(Cat); 对象生成后，可以自行对相关属性进行赋值： myCat.name = ‘mimi’; 12. void在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。 void 0; // undefined 这个命令没什么用，而且很令人困惑，建议避免使用。 ​ 引用自阮一峰博客：http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"Promise探析","slug":"promise","date":"2019-04-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.920Z","comments":true,"path":"2019/04/26/promise/","link":"","permalink":"https://WLL-1017065322.github.io/2019/04/26/promise/","excerpt":"","text":"前言 上一篇，关于axios的二次封装，我们已经探讨过什么是Promise，它可以做什么的问题，现在，我们继续来通过一个简单的DOM案例探析。 你还在这样写？DOM原生事件 根据MDN上面的相关推荐指导，我们应该更多地去使用addEventListener，而非那些原生定义的onclick之类的。 1234567891011//比如我们尝试去添加一个动画效果 window.onload = () =&gt; &#123; document.querySelector(&apos;.app1&apos;) .addEventListener(&apos;mouseenter&apos;, (event) =&gt; &#123; const timer = setInterval(()=&gt;&#123; event.style.opacity += 0.1; if (event.style.opacity === 1) clearInterval(timer); &#125;,1000/20) &#125;); &#125; 我的天呐！一层、两层……总共三层回调，这已经调入回调地狱了，如果再深入设置其他的动画，那岂不是更乱了，想想办法吧。 jQuery写法123456789101112$(()=&gt;&#123; $(&apos;.app&apos;).hover(function(e)=&gt;&#123; const timer = setInterval(()=&gt;&#123; e.css(&#123; opacity:`++0.1` &#125;) if (e.css(&apos;opacity&apos;) === 1) clearInterval(timer); &#125;,1000/20) &#125;); &#125;);&#125;) 一样的酸爽对吧！ 这样做才爽Demo JS部分 1234567891011121314151617181920212223242526272829303132333435363738window.onload = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; document.querySelector(&apos;.app1&apos;) .addEventListener(&apos;mouseenter&apos;, () =&gt; &#123; resolve(&apos;Test&apos;); &#125;); &#125;) .then((data) =&gt; &#123; console.log(data); if (data) &#123; let height = getComputedStyle(document.querySelector(&apos;.app2&apos;))[&apos;top&apos;]; let value = Number.parseInt(height); let timer = setInterval(() =&gt; &#123; value += 10; console.log(value); document.querySelector(&apos;.app2&apos;) .style.top = `-$&#123;value&#125;px`; if (value === 200) &#123; clearInterval(timer); &#125; &#125;, 1000 / 20); &#125; return true; &#125;, (err) =&gt; &#123; console.log(err); &#125;) .then((data) =&gt; &#123; console.log(data); console.log(&apos;开始执行显示&apos;); if (data) &#123; document.querySelector(&apos;.app2&apos;) .style.display = &apos;block&apos;; document.querySelector(&apos;.app2&apos;) .style.opacity = 0.6; &#125; &#125;) &#125; HTML部分 1234567&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;app1&quot;&gt; &lt;img src=&quot;./logo.png&quot; alt=&quot;logo&quot;&gt; &lt;/div&gt; &lt;div class=&quot;app2&quot;&gt; Vue.js &lt;/div&gt; CSS部分 123456789101112131415161718192021&lt;style&gt; .box&#123; width: 300px; margin: 50px auto; &#125; .app1 &#123; width: 200px; height: 200px; &#125; .app2 &#123; width: 200px; height: 200px; background-color: gainsboro; opacity: 8; display: none; text-align: center; position: relative; top: 0; &#125; &lt;/style&gt; 总结 一个Promise可以有多个then函数衔接处理，达到一个同步处理的效果，每次then之后，下一个then接收的是上一个then的return数据，第一个then则接收的是最初的promise回调resolve放行的数据。 引用自： https://ivu1314.club/categories/%E7%BB%8F%E9%AA%8C/","categories":[{"name":"First","slug":"First","permalink":"https://WLL-1017065322.github.io/categories/First/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://WLL-1017065322.github.io/tags/Promise/"}],"author":"along"},{"title":"test_my_site","slug":"test-my-site","date":"2019-03-27T06:36:42.000Z","updated":"2019-05-12T03:46:35.926Z","comments":true,"path":"2019/03/27/test-my-site/","link":"","permalink":"https://WLL-1017065322.github.io/2019/03/27/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"generator","slug":"generator","date":"2019-03-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.909Z","comments":true,"path":"2019/03/26/generator/","link":"","permalink":"https://WLL-1017065322.github.io/2019/03/26/generator/","excerpt":"","text":"generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补Python教程！。 我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果： 12345function foo(x) &#123; return x + x;&#125;var r = foo(1); // 调用foo函数 函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。 generator跟函数很像，定义如下： 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？ 还是举个栗子吧。 我们以一个著名的斐波那契数列为例，它由0，1开头： 10 1 1 2 3 5 8 13 21 34 ... 要编写一个产生斐波那契数列的函数，可以这么写： 12345678910111213141516function fib(max) &#123; var t, a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) &#123; [a, b] = [b, a + b]; arr.push(b); &#125; return arr;&#125;// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下： 12345678910111213function* fib(max) &#123; var t, a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n ++; &#125; return;&#125; 直接调用试试： 1fib(5); // fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125; 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法： 1234567var f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125; next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done： &#39;use strict&#39; function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return; } Run generator和普通函数相比，有什么用？ 因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写： 12345678910111213141516171819var fib = &#123; a: 0, b: 1, n: 0, max: 5, next: function () &#123; var r = this.a, t = this.a + this.b; this.a = this.b; this.b = t; if (this.n &lt; this.max) &#123; this.n ++; return r; &#125; else &#123; return undefined; &#125; &#125;&#125;; 用对象的属性来保存状态，相当繁琐。 generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。 没有generator之前的黑暗时代，用AJAX时需要这么写代码： 12345678910111213141516ajax(&apos;http://url-1&apos;, data1, function (err, result) &#123; if (err) &#123; return handle(err); &#125; ajax(&apos;http://url-2&apos;, data2, function (err, result) &#123; if (err) &#123; return handle(err); &#125; ajax(&apos;http://url-3&apos;, data3, function (err, result) &#123; if (err) &#123; return handle(err); &#125; return success(result); &#125;); &#125;);&#125;); 回调越多，代码越难看。 有了generator的美好时代，用AJAX时可以这么写： 123456789try &#123; r1 = yield ajax(&apos;http://url-1&apos;, data1); r2 = yield ajax(&apos;http://url-2&apos;, data2); r3 = yield ajax(&apos;http://url-3&apos;, data3); success(r3);&#125;catch (err) &#123; handle(err);&#125; 看上去是同步的代码，实际执行是异步的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"alone"},{"title":"前端工程","slug":"前端工程(基础)","date":"2019-03-06T16:00:00.000Z","updated":"2019-05-12T03:46:35.929Z","comments":true,"path":"2019/03/07/前端工程(基础)/","link":"","permalink":"https://WLL-1017065322.github.io/2019/03/07/前端工程(基础)/","excerpt":"","text":"喂喂喂，那个切图的，把页面写好就发给研发工程师套模板吧。 你好，切图仔。 不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。 只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。 前端，是一种GUI软件现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台…… 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件： 尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。 历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！ 前端工程的三个阶段现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段： 第一阶段：库/框架选型 前端工程建设的第一项任务就是根据项目特征进行技术选型。 基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。 第二阶段：简单构建优化 选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。 第三阶段：JS/CSS模块化开发 分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。 很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。 JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。 然而，做到这些就够了么？Naive！ 第四阶段 前端是一种技术问题较少、工程问题较多的软件开发领域。 当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如： 大体量：多功能、多页面、多状态、多系统； 大规模：多人甚至多团队合作开发； 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。 扩展阅读：大公司里怎样开发和部署前端代码？ 这些无疑是一系列严肃的系统工程问题。 前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。 到底，缺什么呢？ 没有银弹读过《人月神话》的人应该都听说过，软件工程 没有银弹。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔） 前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。 重你妹！你的脑容量只有4K吗？ 工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！ 2011年我有幸参与到 FIS 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。 这些经历让我明悟了一个道理： 进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。 第一件事：组件化开发分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求： 如上图，这是我所信仰的前端组件化开发理念，简单解读一下： 页面上的每个 独立的 可视/可交互区域视为一个组件； 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护； 由于组件具有独立性，因此组件与组件之间可以 自由组合； 页面只不过是组件的容器，负责组合组件形成功能完整的界面； 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。 其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。 组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板： 不同的技术选型决定了不同的组件封装和调用策略。 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分： 由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。 结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念： 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子： 示意图 描述 整个Web应用由页面组成 页面由组件组成 一个组件一个目录，资源就近维护 组件可组合， 组件的JS可依赖其他JS模块， CSS可依赖其他CSS单元 综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构： 如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。 以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。 吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。 第二件事：“智能”静态资源管理上面提到的模块化/组件化开发，仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了。 很明显，模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。然而前端与客户端GUI软件有一个很大的不同： 前端是一种远程部署，运行时增量下载的GUI软件 前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。 上图展示了一款界面繁多功能丰富的应用，如果采用Web实现，相信也是不小的体量，如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。 这正是Web应用“免安装”的魅力所在。 由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。 所以我觉得： 第四阶段前端开发最迫切需要做好的就是在基础架构中贯彻增量原则。 相信这种贯彻不会随着时间的推移而改变，在可预见的未来，无论在HTTP1.x还是HTTP2.0时代，无论在ES5亦或者ES6/7时代，无论是AMD/CommonJS/UMD亦或者ES6 module时代，无论端内技术如何变迁，我们都有足够充分的理由要做好前端程序资源的增量加载。 正如前面说到的，第三阶段前端工程缺少点什么呢？我觉得是在其基础架构中缺少这样一种“智能”的资源加载方案。没有这样的方案，很难将前端应用的规模发展到第四阶段，很难实现落地前面介绍的那种组件化开发方案，也很难让多方合作高效率的完成一项大型应用的开发，并保证其最终运行性能良好。在第四阶段，我们需要强大的工程化手段来管理”玩具般简单“的前端开发。 在我的印象中，Facebook是这方面探索的伟大先驱之一，早在2010年的Velocity China大会上，来自Facebook的David Wei博士就为业界展示了他们令人惊艳的静态网页资源管理和优化技术。 David Wei博士在当年的交流会上提到过一些关于Facebook的一些产品数据： Facebook整站有10000+个静态资源； 每个静态资源都有可能被翻译成超过100种语言版本； 每种资源又会针对浏览器生成3种不同的版本； 要针对不同带宽的用户做5种不同的打包方法； 有3、4个不同的用户组，用于小批次体验新的产品功能； 还要考虑不同的送达方法，可以直接送达，或者通过iframe的方式提升资源并行加载的速度； 静态资源的压缩和非压缩状态可切换，用于调试和定位线上问题 这是一个状态爆炸的问题，将所有状态乘起来，整个网站的资源组合方式会达到几百万种之多（去重之后统计大概有300万种组合方式）。支撑这么大规模前端项目运行的底层架构正是魏博士在那次演讲中分享的Static Resource Management System(静态资源管理系统)，用以解决Facebook项目中有关前端工程的3D问题（Development，Deployment，Debugging）。 那段时间 FIS 项目正好遇到瓶颈，当时的FIS还是一个用php写的task-based构建工具，那时候对于前端工程的认知度很低，觉得前端构建不就是几个压缩优化校验打包任务的组合吗，写好流程调度，就针对不同需求写插件呗，看似非常简单。但当我们支撑越来越多的业务团队，接触到各种不同的业务场景时，我们深刻的感受到task-based工具的粗糙，团队每天疲于根据各种业务场景编写各种打包插件，构建逻辑异常复杂，隐隐看到不可控的迹象。 我们很快意识到把基础架构放到构建工具中实现是一件很愚蠢的事，试图依靠构建工具实现各种优化策略使得构建变成了一个巨大的黑盒，一旦发生问题，定位起来非常困难，而且每种业务场景都有不同的优化需求，构建工具只能通过静态分析来优化加载，具有很大的局限性，单页面/多页面/PC端/移动端/前端渲染/后端渲染/多语言/多皮肤/高级优化等等资源加载问题，总不能给每个都写一套工具吧，更何况这些问题彼此之间还可以有多种组合应用，工具根本写不过来。 Facebook的做法无疑为我们亮起了一盏明灯，不过可惜它并不开源（不是技术封锁，而是这个系统依赖FB体系中的其他方面，通用性不强，开源意义不大），我们只能尝试挖掘相关信息，网上对它的完整介绍还是非常非常少，分析facebook的前端代码也没有太多收获，后来无意中发现了facebook使用的项目管理工具phabricator中的一个静态管理方案Celerity，以及相关的说明，看它的描述很像是Facebook静态资源管理系统的一个mini版！ 简单看过整个系统之后发现原理并不复杂（小而美的典范），它是通过一个小工具扫描所有静态资源，生成一张资源表，然后有一个PHP实现的资源管理框架（Celerity）提供了资源加载接口，替代了传统的script/link等静态的资源加载标签，最终通过查表来加载资源。 虽然没有真正看过FB的那套系统，但眼前的这个小小的框架给了当时的我们足够多的启示： 静态资源管理系统 = 资源表 + 资源加载框架 多么优雅的实现啊！ 资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容，比如： 12345678910111213141516&#123; &quot;a.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/a.5f100fa.js&quot;, &quot;dep&quot;: [ &quot;b.js&quot;, &quot;a.css&quot; ] &#125;, &quot;a.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/a.63cf374.css&quot;, &quot;dep&quot;: [ &quot;button.css&quot; ] &#125;, &quot;b.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/b.97193bf.js&quot; &#125;, &quot;button.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/button.de33108.css&quot; &#125;&#125; 而资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。 根据业务场景的不同，加载框架可以在浏览器中用JS实现，也可以是后端模板引擎中用服务端语言实现，甚至二者的组合，不一而足。 有关加载框架的具体实现我曾写过很多文章介绍，可以扩展阅读： 前端工程与性能优化 前端工程与模块化框架 这种设计很快被验证具有足够的灵活性，能够完美支撑不同团队不同技术规范下的性能优化需求，前面提到的按需加载、延迟加载、预加载、请求合并、文件指纹、CDN部署、Bigpipe、Quickling、BigRender、首屏CSS内嵌、HTTP 2.0服务端推送等等性能优化手段都可以很容易的在这种架构上实现，甚至可以根据性能日志自动进行优化（Facebook已实现）。 因为有了资源表，我们可以很方便的控制资源加载，通过各种手段在运行时计算页面的资源使用情况，从而获得最佳加载性能。无论是前端渲染的单页面应用，还是后端渲染的多页面应用，这种方法都同样适用。 此外，它还很巧妙的约束了构建工具的职责——只生成资源表。资源表是非常通用的数据结构，无论什么业务场景，其业务代码最终都可以被扫描为相同结构的表数据，并标记资源间的依赖关系，有了表之后我们只需根据不同的业务场景定制不同的资源加载框架就行了，从此彻底告别一个团队维护一套工具的时代！！！ 恩，如你所见，虽然彻底告别了一个团队一套工具的时代，但似乎又进入了一个团队一套框架的时代。其实还是有差别的，因为框架具有很大的灵活性，而且不那么黑盒，采用框架实现资源管理相比构建更容易调试、定位和升级变更。 深耕静态资源加载框架可以带来许多收益，而且有足够的灵活性和健壮性面向未来的技术变革，这个我们留作后话。 总结回顾一下前面提到过的前端工程三个阶段： 第一阶段：库/框架选型 第二阶段：简单构建优化 第三阶段：JS/CSS模块化开发 现在补充上第四阶段： 第四阶段：组件化开发与资源管理 由于先天缺陷，前端相比其他软件开发，在基础架构上更加迫切的需要组件化开发和资源管理，而解决资源管理的方法其实一点也不复杂： 一个通用的资源表生成工具 + 基于表的资源加载框架 近几年来各种你听到过的各种资源加载优化策略大部分都可以在这样一套基础上实现，而这种优化对于业务来说是完全透明的，不需要重构的性能优化——这不正是我们一直所期盼的吗？正如魏小亮博士所说：我们可以把优秀的人集中起来去优化加载。 如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说： 你好，工程师！","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"前端工程与性能优化","slug":"前端工程与性能优化","date":"2019-03-04T16:00:00.000Z","updated":"2019-05-12T03:46:35.930Z","comments":true,"path":"2019/03/05/前端工程与性能优化/","link":"","permalink":"https://WLL-1017065322.github.io/2019/03/05/前端工程与性能优化/","excerpt":"","text":"优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 开启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 链接地址： fouber/blog#10 http://velocity.oreilly.com.cn/2010/index.php?func=session&amp;name=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"前端演变的理解","slug":"前端演变的理解","date":"2019-03-01T16:00:00.000Z","updated":"2019-05-12T03:46:35.931Z","comments":true,"path":"2019/03/02/前端演变的理解/","link":"","permalink":"https://WLL-1017065322.github.io/2019/03/02/前端演变的理解/","excerpt":"","text":"什么是前端web应用是一种运行在浏览器中的软件，这些软件的图形用户界面（Graphical User Interface, 即GUI）称为前端。（前端是一种GUI应用） 前后端不分离时代 web1.0早期，前后端开发是一体的，网站开发采用后端为主的mvc模式，前端相当于后端的view层。前端的主要工作是编写页面模板，后端代码根据浏览器请求，读取模板，替换变量，生成静态页面，发送给浏览器。 Ajax技术诞生 web2.0 AJAX不是JavaScript的规范，Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 2005年 Ajax 正式提出，前后端分工逐渐清晰，前后端协作的关键是Ajax接口。前端不再是后端的模板，前后端分离，网页也从静态网页转为动态网页。前端开始逐渐复杂。 前端mv*为了降低前端开发的复杂度，出现了大量前端MV*框架比如Backbone，KnockoutJS、AngularJS 等等，对代码进行合理的分层，如models，controllers，view，viewmodel等，让代码各施其职。 前端工程化随着前后端分工的清晰，前端工作的复杂度的增高，开始出现了前端工程化的概念，前端工程化分为几个阶段 技术选型 构建优化 js/css模块化 组件化开发与资源管理 构建优化比如grunt，gulp，对网站资源进行优化如代码压缩，校验，资源合并，对简化前端开发中很多复杂重复的工作，提高开发效率，和执行运行性能。 模块化js的模块化方案很多，如AMD/CommonJS/ES6 Module等css的模块化主要是靠less，sass，stylus等预处理器的import/mixin来支持实现模块化打包工具webpack，parcel，browserify等等 模块化的主要思想在于分而治之，是复杂系统开发和维护的基石。将一个复杂的应用，分成多个更小的部分进行开发与维护，最后再由每一个模块相互作用构成我们的整个应用。 组件化和资源管理组件化也是对分治思想的一种实践，前端作为一种GUI软件，在大型应用中还需要对ui进行组件化开发 页面上每个独立的可视/可交互区域为一个组件 组件间可以自由组合，替换 页面为组件的容器 静态资源管理目前大多数的前端应用都是远程部署，运行时增量下载的GUI软件由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案等等有关前端工程化更详细的了解可到 前端工程 了解 大前端随着nodejs的出现，JavaScript的覆盖范围扩大，大前端的概念也开始出现。大前端的原始定义可以定义为前端技术的扩大化。再后来react native的出现，JavaScript的覆盖范围再一次扩大，拥有了开发跨平台app的能力，大前端的概念进一步加深。前端的工作不再局限于“前端”，必要时时兼顾后端和移动端开发。 总结所以我认为现在的前端应该具备的技术有： html，css，JavaScript过硬的基础。 了解模块化，工程化 深入学习一门JavaScript框架 gulp等自动化构建工具 webpack等模块化资源打包工具 scss，es6等提高生成效率的工具 一门后端语言 有能力的话学习如react native等跨平台技术 作者：holyZheng https://github.com/HolyZheng/holyZheng-blog/issues/1","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"错误处理","slug":"错误处理","date":"2019-02-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.937Z","comments":true,"path":"2019/02/26/错误处理/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/26/错误处理/","excerpt":"","text":"错误处理在执行JavaScript代码的时候，有些情况下会发生错误。 错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如： 12var s = null;var len = s.length; // TypeError：null变量没有length属性 对于这种错误，要修复程序。 一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。 对于这种错误，我们需要处理它，并可能需要给用户反馈。 错误处理是程序设计时必须要考虑的问题。对于C这样贴近系统底层的语言，错误是通过错误码返回的： 123456int fd = open(&quot;/path/to/file&quot;, O_RDONLY);if (fd == -1) &#123; printf(&quot;Error when open file!&quot;);&#125; else &#123; // TODO&#125; 通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的open()函数约定返回-1表示错误。 显然，这种用错误码表示错误在编写程序时十分不便。 因此，高级语言通常都提供了更抽象的错误处理逻辑try … catch … finally，JavaScript也不例外。 try … catch … finally使用try … catch … finally处理错误时，我们编写的代码如下： &#39;use strict&#39;; `// 直接运行` 1234567891011var r1, r2, s = null;try &#123; r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行&#125; catch (e) &#123; console.log('出错了：' + e);&#125; finally &#123; console.log('finally');&#125;console.log('r1 = ' + r1); // r1应为undefinedconsole.log('r2 = ' + r2); // r2应为undefined 1234出错了：TypeError: Cannot read property 'length' of nullfinallyr1 = undefinedr2 = undefined 运行后可以发现，输出提示类似“出错了：TypeError: Cannot read property ‘length’ of null”。 我们来分析一下使用try … catch … finally的执行流程。 当代码块被try { ... }包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到catch块。catch (e) { ... }包裹的代码就是错误处理代码，变量e表示捕获到的错误。最后，无论有没有错误，finally一定会被执行。 所以，有错误发生时，执行流程像这样： 先执行try { ... }的代码； 执行到出错的语句时，后续语句不再继续执行，转而执行catch (e) { ... }代码； 最后执行finally { ... }代码。 而没有错误发生时，执行流程像这样： 先执行try { ... }的代码； 因为没有出错，catch (e) { ... }代码不会被执行； 最后执行finally { ... }代码。 最后请注意，catch和finally可以不必都出现。也就是说，try语句一共有三种形式： 完整的try … catch … finally： 1234567try &#123; ...&#125; catch (e) &#123; ...&#125; finally &#123; ...&#125; 只有try … catch，没有finally： 12345try &#123; ...&#125; catch (e) &#123; ...&#125; 只有try … finally，没有catch： 12345try &#123; ...&#125; finally &#123; ...&#125; 错误类型JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象： 1234567891011try &#123; ...&#125; catch (e) &#123; if (e instanceof TypeError) &#123; alert(&apos;Type error!&apos;); &#125; else if (e instanceof Error) &#123; alert(e.message); &#125; else &#123; alert(&apos;Error: &apos; + e); &#125;&#125; 使用变量e是一个习惯用法，也可以以其他变量名命名，如catch(ex)。 抛出错误程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。 例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用parseInt()转换为整数。当用户输入不合法的时候，我们就抛出错误： &#39;use strict&#39;; `// 直接运行 ` Run 12345678910111213var r, n, s;try &#123; s = prompt('请输入一个数字'); n = parseInt(s); if (isNaN(n)) &#123; throw new Error('输入错误'); &#125; // 计算平方: r = n * n; console.log(n + ' * ' + n + ' = ' + r);&#125; catch (e) &#123; console.log('出错了：' + e);&#125; 1出错了：Error: 输入错误 实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。 最后，当我们用catch捕获错误时，一定要编写错误处理语句： 1234567var n = 0, s;try &#123; n = s.length;&#125; catch (e) &#123; console.log(e);&#125;console.log(n); 哪怕仅仅把错误打印出来，也不要什么也不干： 123456var n = 0, s;try &#123; n = s.length;&#125; catch (e) &#123;&#125;console.log(n); 因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。 处理错误时，请不要简单粗暴地用alert()把错误显示给用户。教程的代码使用alert()是为了便于演示。 异步错误处理：编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。 例如，setTimeout()函数可以传入回调函数，并在指定若干毫秒后执行： 123456function printTime() &#123; console.log(&apos;It is time!&apos;);&#125;setTimeout(printTime, 1000);console.log(&apos;done&apos;); 上面的代码会先打印done，1秒后才会打印It is time!。 如果printTime()函数内部发生了错误，我们试图用try包裹setTimeout()是无效的： 123456789101112function printTime() &#123; throw new Error();&#125;try &#123; setTimeout(printTime, 1000); console.log('done');&#125; catch (e) &#123; console.log('error');&#125;//done 原因就在于调用setTimeout()函数时，传入的printTime函数并未立刻执行！紧接着，JavaScript引擎会继续执行console.log(&#39;done&#39;);语句，而此时并没有错误发生。直到1秒钟后，执行printTime函数时才发生错误，但此时除了在printTime函数内部捕获错误外，外层代码并无法捕获。 所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。 类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。 例如，针对以下的表单： 1234&lt;form&gt; &lt;input id=\"x\"&gt; + &lt;input id=\"y\"&gt; &lt;button id=\"calc\" type=\"button\"&gt;计算&lt;/button&gt;&lt;/form&gt; 1234567891011121314151617try &#123; $btn.click(function () &#123; var x = parseFloat($('#x').val()), y = parseFloat($('#y').val()), r; if (isNaN(x) || isNaN(y)) &#123; throw new Error('输入有误'); &#125; r = x + y; alert('计算结果：' + r); &#125;);&#125; catch (e) &#123; alert('输入有误！');&#125;// 我们用下面的代码给button绑定click事件： 1234567891011121314151617'use strict'; var $btn = $('#calc'); // 取消已绑定的事件: $btn.off('click'); try &#123; $btn.click(function () &#123; var x = parseFloat($('#x').val()), y = parseFloat($('#y').val()), r; if (isNaN(x) || isNaN(y)) &#123; throw new Error('输入有误'); &#125; r = x + y; alert('计算结果：' + r); &#125;);&#125; catch (e) &#123; alert('输入有误！');&#125; 错误传播如果代码发生了错误，又没有被try … catch捕获，那么，程序执行流程会跳转到哪呢？ 12345678910function getLength(s) &#123; return s.length;&#125;function printLength() &#123; console.log(getLength(&apos;abc&apos;)); // 3 console.log(getLength(null)); // Error!&#125;printLength(); 如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽： &#39;use strict&#39;; `// 直接运行，观察控制台输出 ` Run 1234567891011121314151617181920212223function main(s) &#123; console.log('BEGIN main()'); try &#123; foo(s); &#125; catch (e) &#123; console.log('出错了：' + e); &#125; console.log('END main()');&#125;function foo(s) &#123; console.log('BEGIN foo()'); bar(s); console.log('END foo()');&#125;function bar(s) &#123; console.log('BEGIN bar()'); console.log('length = ' + s.length); console.log('END bar()');&#125;main(null); 12345BEGIN main()BEGIN foo()BEGIN bar()出错了：TypeError: Cannot read property 'length' of nullEND main() 当bar()函数传入参数null时，代码会报错，错误会向上抛给调用方foo()函数，foo()函数没有try … catch语句，所以错误继续向上抛给调用方main()函数，main()函数有try … catch语句，所以错误最终在main()函数被处理了。 至于在哪些地方捕获错误比较合适，需要视情况而定。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"箭头函数","slug":"箭头函数","date":"2019-02-22T16:00:00.000Z","updated":"2019-05-12T03:46:35.936Z","comments":true,"path":"2019/02/23/箭头函数/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/23/箭头函数/","excerpt":"","text":"ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 为什么叫Arrow Function？因为它的定义用的就是一个箭头： 1x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function： &#39;use strict&#39;; `console.log(‘你的浏览器支持ES6的Arrow Function!’); ` Run 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来： 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 12// SyntaxError:x =&gt; &#123; foo: x &#125; 因为和函数体的{ ... }有语法冲突，所以要改为： 12// ok:x =&gt; (&#123; foo: x &#125;) this箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果： 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj： 123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： 1var that = this; 就不再需要了。 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 123456789var obj = &#123; birth: 1990, getAge: function (year) &#123; var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call(&#123;birth:2000&#125;, year); &#125;&#125;;obj.getAge(2015); // 25 转载自： https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"执行上下文栈","slug":"执行上下文栈","date":"2019-02-20T16:00:00.000Z","updated":"2019-05-12T03:46:35.934Z","comments":true,"path":"2019/02/21/执行上下文栈/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/21/执行上下文栈/","excerpt":"","text":"在ECMASscript中的代码有三种类型：global, function和eval。 每一种代码的执行都需要依赖自身的上下文。当然global的上下文可能涵盖了很多的function和eval的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。 注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 12345678function foo(bar) &#123;&#125;// 调用相同的function，每次都会产生3个不同的上下文//（包含不同的状态，例如参数bar的值）foo(10);foo(20);foo(30); 一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。 激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。 当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，称为进行中的上下文[running/active execution context]. 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。在这个caller结束之后，会继续触发其他的上下文。一个callee可以用返回（return）或者抛出异常（exception）来结束自身的上下文。 如下图，所有的ECMAScript的程序执行都可以看做是一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。 图 4. 执行上下文栈 当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。 见图5，有一个函数上下文“EC1″和一个全局上下文“Global EC”，下图展现了从“Global EC”进入和退出“EC1″时栈的变化: 图 5. 执行上下文栈的变化 ECMAScript运行时系统就是这样管理代码的执行。 关于ECMAScript执行上下文栈的内容请查阅本系列教程的第11章执行上下文(Execution context)。 如上所述，栈中每一个执行上下文可以表示为一个对象。让我们看看上下文对象的结构以及执行其代码所需的 状态(state) 。 执行上下文(Execution Context)一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。这个图示就是一个context的结构。 图 6. 上下文结构 除了这3个所需要的属性(变量对象(variable object)，this指针(this value)，作用域链(scope chain) )，执行上下文根据具体实现还可以具有任意额外属性。接着，让我们仔细来看看这三个属性。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"探究同步异步工作原理","slug":"探究同步异步工作原理","date":"2019-02-18T16:00:00.000Z","updated":"2019-05-12T03:46:35.935Z","comments":true,"path":"2019/02/19/探究同步异步工作原理/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/19/探究同步异步工作原理/","excerpt":"","text":"前言 JS引擎在运行同步代码的时候按照顺序运行的方式，而如果遇见异步代码将会短暂挂起，放入事件循环队列(Event Loop)末端，一次执行。 12345678//you may have seen the following codefor (var i = 0; i &lt; 3; i++) &#123; setTimeout(function timeoutHandle() &#123; console.log(i); &#125;,1000);&#125; 但是如果如上述代码所示，加上一个定时器又如何理解呢？在同步代码循环结束完毕之后，三个异步事件挂起，等到1秒时间到了之后，三个异步事件依次放入事件循环队列中执行，而同步代码中循环中的每一次迭代都会给自己捕获一个i的副本，但是根据作用域的工作原理，实际情况是尽管循环中的三个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域中，因此实际只有一个i。 探析 对于var关键字声明变量有着诸多诟病，那就是会造成污染全局变量的风险，比如上述的for循环中，假如在for循环体之外再次打印，引擎依旧会给出泄露出去的全局变量i，当然这是很危险的。我们不妨用一下let关键字。 12345for (let i = 0; i &lt; 3; i++ )&#123; setTimeout(function timeoutHandle() &#123; console.log(i); &#125;);&#125; 你会惊喜的发现打印结果是预期顺序。 那是因为for循环的头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次。每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 原始链接： https://bigbigdreamer.github.io/76f810b0/","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"原型链-继承","slug":"原型链继承","date":"2019-02-17T16:00:00.000Z","updated":"2019-05-12T03:46:35.932Z","comments":true,"path":"2019/02/18/原型链继承/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/18/原型链继承/","excerpt":"","text":"前言：​ 对于有基于类的语言经验 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 ​ 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的原型对象（ prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 ​ 尽管这种原型继承通常被认为是 JavaScript 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。 ### 原型：原型的概念定义为：所谓原型就是指函数的prototype属性所引用的对象，这个对象就是原型。 作用1：实现对象之间的数据共享。2.在es6之前，没有class的情况下，模拟面向对象，构造函数中放私有属性，原型上放公有属性，一般为方法。 获取原型的方法：1.函数.prototype；2.对象._ proto （如果当前浏览器不支持.proto _，那么就通过对象的构造函数找：.constructor.prototype；原型本身是一个对象。 原型（prototype）： 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。 原型对象默认拥有一个constructor属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。 每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过 Object.getPrototypeOf(obj) 或 obj.__proto__ 来访问。 实际上，构造函数的prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即 对象.__proto__ === 函数.prototype 。 如上文所述，原型对象就是用来存放实例中共有的那部分属性。 在JavaScript中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。 访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。 作者：clancysong 链接：https://juejin.im/post/5a94c0de5188257a8929d837 原型链：概念：原型链是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，即prototype属性。 作用：原型链的存在，主要是为了实现对象的继承。 继承：1、函数对象在JavaScript中，函数即对象。 2、原型对象当定义一个函数对象的时候，会包含一个预定义的属性，叫prototype，这就属性称之为原型对象。 123//函数对象function F()&#123;&#125;;console.log(F.prototype) 123//普通对象var a = &#123;&#125;;console.log(a.prototype);//undefined 3、__prot__JavaScript在创建对象的时候，都会有一个[[proto]]的内置属性，用于指向创建它的函数对象的prototype。原型对象也有[[proto]]属性。因此在不断的指向中，形成了原型链。 举个例子来说，我们将对象F的原型对象修改一下，就可以清楚看到上述的关系 1234567//函数对象function F()&#123;&#125;;F.prototype = &#123; hello : function()&#123;&#125;&#125;;var f = new F();console.log(f.__proto__) 4、new当使用new去调用构造函数时，相当于执行了 123var o = &#123;&#125;;o.__proto__ = F.prototype;F.call(o); 因此，在原型链的实现上，new起到了很关键的作用。 5、constructor原型对象prototype上都有个预定义的constructor属性，用来引用它的函数对象。这是一种循环引用。 12function F()&#123;&#125;;F.prototype.constructor === F; 在实际运用中，经常会有下列的写法 12345function F()&#123;&#125;;F.prototype = &#123; constructor : F, doSomething : function()&#123;&#125;&#125; 这里要加constructor是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。 6、原型链的内存结构12345function F()&#123; this.name = &apos;zhang&apos;;&#125;;var f1 = new F();var f2 = new F(); 为了严谨起见，区分对象和变量 简单回顾下构造函数,原型和实例的关系: 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针. JS对象的圈子里有这么个游戏规则: 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性. 如果让原型对象指向另一个类型的实例…..有趣的事情便发生了. 即: constructor1.prototype = instance2 鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1: 1).首先会在instance1内部属性中找一遍; 2).接着会在instance1.proto(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1; 3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.proto(constructor2.prototype)中寻找…直至Object的原型对象 搜索轨迹: instance1–&gt; instance2 –&gt; constructor2.prototype…–&gt;Object.prototype 这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 原型链 . 下面有个例子 1234567891011121314151617function Father()&#123; this.property = true;&#125;Father.prototype.getFatherValue = function()&#123; return this.property;&#125;function Son()&#123; this.sonProperty = false;&#125;//继承 FatherSon.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写Son.prototype.getSonVaule = function()&#123; return this.sonProperty;&#125;var instance = new Son();alert(instance.getFatherValue());//true12345678910111213141516 instance实例通过原型链找到了Father原型中的getFatherValue方法. 注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故. 确定原型和实例的关系使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种. 第一种是使用 instanceof 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点. 1234alert(instance instanceof Object);//truealert(instance instanceof Father);//truealert(instance instanceof Son);//true123 由于原型链的关系, 我们可以说instance 是 Object, Father 或 Son中任何一个类型的实例. 因此, 这三个构造函数的结果都返回了true. 第二种是使用 isPrototypeOf() 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示. 1234alert(Object.prototype.isPrototypeOf(instance));//truealert(Father.prototype.isPrototypeOf(instance));//truealert(Son.prototype.isPrototypeOf(instance));//true123 原理同上. 原型链的问题原型链并非十分完美, 它包含如下两个问题. 问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享; 问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数. 有鉴于此, 实践中很少会单独使用原型链. 为此,下面将有一些尝试以弥补原型链的不足. 借用构造函数为解决原型链中上述两个问题, 我们开始使用一种叫做借用构造函数(constructor stealing)的技术(也叫经典继承). 基本思想:即在子类型构造函数的内部调用超类型构造函数. 12345678910111213function Father()&#123; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;var instance2 = new Son();console.log(instance2.colors);//&quot;red,blue,green&quot; 可见引用类型值是独立的123456789101112 很明显,借用构造函数一举解决了原型链的两大问题: 其一, 保证了原型链中引用类型值的独立,不再被所有实例共享; 其二, 子类型创建时也能够向父类型传递参数. 随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用. 组合继承组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式. 基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承. 这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示. 1234567891011121314151617181920212223242526function Father(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;Son.prototype = new Father();//继承父类方法,第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son(&quot;louis&quot;,5);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son(&quot;zhai&quot;,10);console.log(instance1.colors);//&quot;red,blue,green&quot;instance1.sayName();//zhaiinstance1.sayAge();//1012345678910111213141516171819202122232425 组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象. 同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到. 原型继承该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下: 在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例. 123456function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;12345 从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制. 123456789var person = &#123; friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]&#125;;var anotherPerson = object(person);anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.friends.push(&quot;Style&quot;);alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;12345678 在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享. 在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承. object.create() 接收两个参数: 一个用作新对象原型的对象 (可选的)一个为新对象定义额外属性的对象 123456789var person = &#123; friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.friends.push(&quot;Style&quot;);alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;12345678 object.create() 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如: 12345678910var person = &#123; name : &quot;Van&quot;&#125;;var anotherPerson = Object.create(person, &#123; name : &#123; value : &quot;Louis&quot; &#125;&#125;);alert(anotherPerson.name);//&quot;Louis&quot;123456789 目前支持 Object.create() 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome. 提醒: 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样. 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之. 寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象. 如下. 12345678function createAnother(original)&#123; var clone = object(original);//通过调用object函数创建一个新对象 clone.sayHi = function()&#123;//以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone;//返回这个对象&#125;1234567 这个例子中的代码基于person返回了一个新对象–anotherPerson. 新对象不仅具有 person 的所有属性和方法, 而且还被增强了, 拥有了sayH()方法. 注意: 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似. 寄生组合式继承前面讲过,组合继承是 JavaScript 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. 寄生组合式继承就是为了降低调用父类构造函数的开销而出现的 . 其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数 123456function extend(subClass,superClass)&#123; var prototype = object(superClass.prototype);//创建对象 prototype.constructor = subClass;//增强对象 subClass.prototype = prototype;//指定对象&#125;12345 extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法. 以上,寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法. 下面我们来看下extend的另一种更为有效的扩展. 123456789101112function extend(subClass, superClass) &#123; var F = function() &#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(superClass.prototype.constructor == Object.prototype.constructor) &#123; superClass.prototype.constructor = superClass; &#125;&#125;1234567891011 我一直不太明白的是为什么要 “new F()“, 既然extend的目的是将子类型的 prototype 指向超类型的 prototype,为什么不直接做如下操作呢? 12subClass.prototype = superClass.prototype;//直接指向超类型prototype1 显然, 基于如上操作, 子类型原型将与超类型原型共用, 根本就没有继承关系. new 运算符为了追本溯源, 我顺便研究了new运算符具体干了什么?发现其实很简单，就干了三件事情. 1234var obj = &#123;&#125;;obj.__proto__ = F.prototype;F.call(obj);123 第一行，我们创建了一个空对象obj; 第二行，我们将这个空对象的proto成员指向了F函数对象prototype成员对象; 第三行，我们将F函数对象的this指针替换成obj，然后再调用F函数. 我们可以这么理解: 以 new 操作符调用构造函数的时候，函数内部实际上发生以下变化： 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this. proto 属性是指定原型的关键以上, 通过设置 proto 属性继承了父类, 如果去掉new 操作, 直接参考如下写法 12subClass.prototype = superClass.prototype;//直接指向超类型prototype1 那么, 使用 instanceof 方法判断对象是否是构造器的实例时, 将会出现紊乱. 假如参考如上写法, 那么extend代码应该为 123456789function extend(subClass, superClass) &#123; subClass.prototype = superClass.prototype; subClass.superclass = superClass.prototype; if(superClass.prototype.constructor == Object.prototype.constructor) &#123; superClass.prototype.constructor = superClass; &#125;&#125;12345678 此时, 请看如下测试: 1234567function a()&#123;&#125;function b()&#123;&#125;extend(b,a);var c = new a()&#123;&#125;;console.log(c instanceof a);//trueconsole.log(c instanceof b);//true123456 c被认为是a的实例可以理解, 也是对的; 但c却被认为也是b的实例, 这就不对了. 究其原因, instanceof 操作符比较的应该是 c.proto 与 构造器.prototype(即 b.prototype 或 a.prototype) 这两者是否相等, 又extend(b,a); 则b.prototype === a.prototype, 故这才打印出上述不合理的输出. 那么最终,原型链继承可以这么实现,例如: 1234567891011121314151617181920212223242526function Father(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;extend(Son,Father)//继承父类方法,此处并不会第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son(&quot;louis&quot;,5);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son(&quot;zhai&quot;,10);console.log(instance1.colors);//&quot;red,blue,green&quot;instance1.sayName();//zhaiinstance1.sayAge();//1012345678910111213141516171819202122232425 扩展:属性查找1234使用了原型链后, 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined. 此时若想避免原型链查找, 建议使用 **hasOwnProperty** 方法. 因为 **hasOwnProperty** 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数. 如:1console.log(instance1.hasOwnProperty(&apos;age&apos;));//true1 对比: isPrototypeOf 则是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false。如: 12console.log(Father.prototype.isPrototypeOf(instance1));//true1 instanceof &amp;&amp; typeof上面提到几次提到 instanceof 运算符. 那么到底它是怎么玩的呢? 下面让我们来趴一趴它的使用场景. instanceof 运算符是用来在运行时指出对象是否是构造器的一个实例, 例如漏写了new运算符去调用某个构造器, 此时构造器内部可以通过 instanceof 来判断.(java中功能类似) 123456789function f()&#123; if(this instanceof arguments.callee) console.log(&apos;此处作为构造函数被调用&apos;); else console.log(&apos;此处作为普通函数被调用&apos;);&#125;f();//此处作为普通函数被调用new f();//此处作为构造函数被调用12345678 以上, this instanceof arguments.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用的。 对比: typeof 则用以获取一个变量或者表达式的类型, 一般只能返回如下几个结果: number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。 new运算符此处引用 艾伦的 JS 对象机制深剖——new 运算符 接着上述对new运算符的研究, 我们来考察 ECMAScript 语言规范中 new 运算符的定义： The new Operator The production NewExpression : new NewExpression is evaluated as follows:Evaluate NewExpression.Call GetValue(Result(1)).If Type(Result(2)) is not Object, throw a TypeError exception.If Result(2) does not implement the internal [[Construc]] method, throw a TypeError exception.Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).Return Result(5). 其大意是，new 后必须跟一个对象并且此对象必须有一个名为 [[Construct]] 的内部方法（其实这种对象就是构造器），否则会抛出异常 根据这些内容，我们完全可以构造一个伪 [[Construct]] 方法来模拟此流程 12345678910111213141516function MyObject(age) &#123; this.age = age;&#125;MyObject.construct = function() &#123; var o = &#123;&#125;, Constructor = MyObject; o.__proto__ = Constructor.prototype; // FF 支持用户引用内部属性 [[Prototype]] Constructor.apply(o, arguments); return o;&#125;;var obj1 = new MyObject(10);var obj2 = MyObject.construct(10);alert(obj2 instanceof MyObject);// true123456789101112131415 解释：","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"},{"name":"原型链","slug":"原型链","permalink":"https://WLL-1017065322.github.io/tags/原型链/"}],"author":"along"},{"title":"闭包","slug":"闭包","date":"2019-02-14T16:00:00.000Z","updated":"2019-05-12T03:46:35.938Z","comments":true,"path":"2019/02/15/闭包/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/15/闭包/","excerpt":"","text":"​ 闭包是指有权访问另一个函数作用域中的变量的函数；常见方式就是在一个函数内部创建另一个函数。 ​ JavaScript 闭包的本质源自两点，词法作用域和函数当作值传递。 词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。 引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。 ​ 通俗地讲就是别人家有某个东西，你想拿到但是因为权限不够（不打死你才怪），但是你可以跟家里的孩子套近乎，通过他拿到！这个家就是局部作用域，外部无法访问内部变量，孩子是返回对象，对家里的东西有访问权限，借助返回对象间接访问内部变量！ 例子： 12345678910function makeFunc() &#123; var name = \"Mozilla\"; function displayName() &#123; alert(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); ​ JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 ​ 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"作用域链","slug":"作用域链","date":"2019-02-09T16:00:00.000Z","updated":"2019-05-12T03:46:35.928Z","comments":true,"path":"2019/02/10/作用域链/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/10/作用域链/","excerpt":"","text":"12A scope chain is a list of objects that are searched for identifiers appear in the code of the context.作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。 标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。例如，当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明（或者也不是某个参数名），那么这个变量就可以称为自由变量[free variable]。那么我们搜寻这些自由变量就需要用到作用域链。 在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如with或者catch语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]。 当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。 1234567891011var x = 10; (function foo() &#123; var y = 20; (function bar() &#123; var z = 30; // &quot;x&quot;和&quot;y&quot;是自由变量 // 会在作用域链的下一个对象中找到（函数”bar”的互动对象之后） console.log(x + y + z); &#125;)();&#125;)(); 我们假设作用域链的对象联动是通过一个叫做parent的属性，它是指向作用域链的下一个对象。这可以在Rhino Code中测试一下这种流程，这种技术也确实在ES5环境中实现了(有一个称为outer链接).当然也可以用一个简单的数据来模拟这个模型。使用parent的概念，我们可以把上面的代码演示成如下的情况。（因此，父级变量是被存在函数的[[Scope]]属性中的）。 图 9. 作用域链 在代码执行过程中，如果使用with或者catch语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻。 ​ 首先在原本的作用域链 ​ 每一个链接点的作用域的链（如果这个链接点是有prototype的话） 我们再看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435Object.prototype.x = 10; var w = 20;var y = 30; // 在SpiderMonkey全局对象里// 例如，全局上下文的变量对象是从&quot;Object.prototype&quot;继承到的// 所以我们可以得到“没有声明的全局变量”// 因为可以从原型链中获取 console.log(x); // 10 (function foo() &#123; // &quot;foo&quot; 是局部变量 var w = 40; var x = 100; // &quot;x&quot; 可以从&quot;Object.prototype&quot;得到，注意值是10哦 // 因为&#123;z: 50&#125;是从它那里继承的 with (&#123;z: 50&#125;) &#123; console.log(w, x, y , z); // 40, 10, 30, 50 &#125; // 在&quot;with&quot;对象从作用域链删除之后 // x又可以从foo的上下文中得到了，注意这次值又回到了100哦 // &quot;w&quot; 也是局部变量 console.log(x, w); // 100, 40 // 在浏览器里 // 我们可以通过如下语句来得到全局的w值 console.log(window.w); // 20 &#125;)(); 我们就会有如下结构图示。这表示，在我们去搜寻parent之前，首先会去proto的链接中。 图 10. with增大的作用域链 注意，不是所有的全局对象都是由Object.prototype继承而来的。上述图示的情况可以在SpiderMonkey中测试。 只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处——我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 销毁(destroyed) ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在ECMAScript中与作用域链直接相关，被称为 (词法)闭包((lexical) closure)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"this指针","slug":"this指针","date":"2019-02-09T16:00:00.000Z","updated":"2019-05-12T03:46:35.926Z","comments":true,"path":"2019/02/10/this指针/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/10/this指针/","excerpt":"","text":"123A this value is a special object which is related with the execution context. Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated).this适合执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象[context object](激活执行上下文的上下文)。 任何对象都可以作为上下文的this值。我想再次澄清对与ECMAScript中，与执行上下文相关的一些描述——特别是this的误解。通常，this 被错误地，描述为变量对象的属性。最近比如在这本书中就发现了(尽管书中提及this的那一章还不错)。 请牢记： 12a this value is a property of the execution context, but not a property of the variable object.this是执行上下文环境的一个属性，而不是某个变量对象的属性 这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this,这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决中进入上下文时的情况。 顺便说一句，和ECMAScript不同，Python有一个self的参数，和this的情况差不多，但是可以在执行过程中被改变。在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。 在global context(全局上下文)中，this的值就是指全局这个对象，这就意味着，this值就是这个变量本身。 1234567var x = 10; console.log( x, // 10 this.x, // 10 window.x // 10); 在函数上下文[function context]中，this会可能会根据每次的函数调用而成为不同的值.this会由每一次caller提供,caller是通过调用表达式[call expression]产生的（也就是这个函数如何被激活调用的）。例如，下面的例子中foo就是一个callee，在全局上下文中被激活。下面的例子就表明了不同的caller引起this的不同。 1234567891011121314151617181920212223242526// &quot;foo&quot;函数里的alert没有改变// 但每次激活调用的时候this是不同的 function foo() &#123; alert(this);&#125; // caller 激活 &quot;foo&quot;这个callee，// 并且提供&quot;this&quot;给这个 callee foo(); // 全局对象foo.prototype.constructor(); // foo.prototype var bar = &#123; baz: foo&#125;; bar.baz(); // bar (bar.baz)(); // also bar(bar.baz = bar.baz)(); // 这是一个全局对象(bar.baz, bar.baz)(); // 也是全局对象(false || bar.baz)(); // 也是全局对象 var otherFoo = bar.baz;otherFoo(); // 还是全局对象 如果要深入思考每一次函数调用中，this值的变化(更重要的是怎样变化)，你可以阅读本系列教程第10章This。上文所提及的情况都会在此章内详细讨论。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"canvas","slug":"canvas","date":"2019-02-06T16:00:00.000Z","updated":"2019-05-12T03:46:35.908Z","comments":true,"path":"2019/02/07/canvas/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/07/canvas/","excerpt":"","text":"Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。 一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制： 1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 由于浏览器对HTML5标准支持不一致，所以，通常在&lt;canvas&gt;内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略&lt;canvas&gt;内部的HTML，如果浏览器不支持Canvas，它将显示&lt;canvas&gt;内部的HTML： 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas： 1234&lt;!-- HTML代码 --&gt;&lt;canvas id=&quot;test-canvas&quot; width=&quot;200&quot; heigth=&quot;100&quot;&gt; &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt; getContext(&#39;2d&#39;)方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。 1var ctx = canvas.getContext(&apos;2d&apos;); 如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形： 1gl = canvas.getContext(&quot;webgl&quot;); 本节我们只专注于绘制2D图形。 绘制形状我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统： Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。 CanvasRenderingContext2D对象有若干方法来绘制图形： 12345&apos;use strict&apos;;var canvas = document.getElementById(&apos;test-shape-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); (no output) 绘制文本绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致： 12345&apos;use strict&apos;;var canvas = document.getElementById(&apos;test-text-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); (no output) Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案： 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中； 尽量使用整数坐标而不是浮点数； 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图； 背景图片如果不变可以直接用&lt;img&gt;标签并放到最底层。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://WLL-1017065322.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://WLL-1017065322.github.io/tags/canvas/"}],"author":"along"},{"title":"js--进阶","slug":"JS核心知识归纳(进阶)","date":"2019-02-03T16:00:00.000Z","updated":"2019-05-12T03:46:35.829Z","comments":true,"path":"2019/02/04/JS核心知识归纳(进阶)/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/04/JS核心知识归纳(进阶)/","excerpt":"","text":"js–进阶1.原型链许多OO语言支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。由于函数无签名，在JavaScript中无法实现接口继承。所以只能实现方法继承。实现继承主要依赖原型链。基本思想：利用原型，让那个一个引用类型继承另一个引用类型的属性和方法。A.prototype= new B();让原型对象等于另一个类型的实例。所有函数的默认原型都是Object的实例即A继承了B ；B 继承了Object; 什么是原型对象。我们知道每个构造函数一旦创建都有prototype指针指向它的原型对象（构造函数.prototype）。而原型对象（构造函数.prototype）会默认生成一个constructor指针又指向构造函数。在创建实例时，每个实例有一个proto指向该原型对象。原型对象内创建的所有方法会被所有实例共享。例： 12345Function.prototype = &#123; constructor : Function, __proto__ : parent prototype, some prototype properties: ... &#125;; 原型对象中的方法属性是被所有实例共享的。如果含有引用类型的属性，如数组，修改person1中的数组属性，也会导致person2中的该属性发生变化。 什么是原型链？函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针proto，该指针指向上一层的原型对象，而上一层的原型对象的结构依然类似，这样利用proto一直指向Object的原型对象上，而Object的原型对象用Object.prototype.proto = null表示原型链的最顶端，如此变形成了javascript的原型链继承，同时也解释了为什么所有的javascript对象都具有Object的基本方法。 原型链就是创建一个构造函数，它会默认生成一个prototype属性并指向原型对象。使用下一个构造函数的原型对象作为这个构造函数的实例。即 A.prototype = new B(); 在下下一个构造函数的原型对象 = new nextFuction。这样下去就会构成一条实例与原型之间的链条，这就是原型链。 2.继承构造函数A()和实例a1 a2之间的关系；var a1 = new A(); var a2 = new A();实例a1与实例a2是独立的实例和原型的关系 a1.proto = A.prototype构造函数A()和其原型的关系 A.prototype.constructor=A 6种继承方式原型链继承本质:是子用类型B的原型等于超类型的实例,B.prototype= new A() 构造函数继承本质:是子用类型的构造函数内部调用A(),B(){A.call(this,**);} 组合继承本质原型链和构造函数的组合，原型继承方法，构造函数继承属性 原型式继承本质:基于已有对象创建一个对象,即对象A的浅拷贝,var b= Object.create(A) 寄生式继承本质:创建一个用于封装继承过程的函数,function b(A){var clone = Object.create(A) ;clone.=;return clone;} 寄生组合继承本质:寄生式继承超类型A的原型,并将结果赋值给子类型的原型;或对对象A的原型浅拷贝，function B(**){ 1A.call(this,**) }function c(A,B){var clone = Object.create(A.prototype); clone.constructor = B;B.prototype=clone;) ;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 function Person(name) &#123; this.name = [&apos;123&apos;,&apos;456&apos;,&apos;789&apos;,name]; &#125; Person.prototype.go = function()&#123; return console.log(this.name) &#125; Person.prototype.sex = [&apos;男&apos;,&apos;女&apos;]; var ren = new Person(); console.log(&apos;构造函数和原型的关系:&apos;,Person.prototype.constructor ===Person) console.log(&apos;实例和原型的关系&apos;,ren.__proto__ ===Person.prototype) // 原型链继承 // 缺点1.不能向person中传递参数； // 缺点2.超类型的原型属性会被其他实例共享，一个实例改变，则其他实例也改变。 // 下面2个原型的顺序不能换 function Shuagnfeng(love) &#123; this.love = [&apos;fd&apos;,&apos;fddfdf&apos;]; &#125; Shuagnfeng.prototype = new Person(); console.log(&apos;会误会超类型Person:&apos;,Shuagnfeng.prototype.constructor ===Person) //true console.log(&apos;构成原型链,&apos;,Shuagnfeng.prototype.__proto__ ===Person.prototype) //true Shuagnfeng.prototype.constructor ===Shuagnfeng; Shuagnfeng.prototype.goWork = function()&#123; return console.log(&apos;原型链继承的方法&apos;); &#125; var child = new Person();Shuagnfeng.prototype.name.push(121);console.log(&apos;超类型实例2 child&apos;,child.name); var xiaozhang = new Shuagnfeng(&apos;dff&apos;); var xiaozhang1 = new Shuagnfeng(&apos;zzz&apos;); xiaozhang.go(); xiaozhang.goWork(); xiaozhang.name.push(&apos;只对xiaozhang增加属于超类型Person中array值&apos;,22); xiaozhang.love.push(&apos;只对xiaozhang增加属于构造函数中array值&apos;,22); xiaozhang.sex.push(&apos;只对xiaozhang增加属于超类型的原型中array值&apos;); console.log(&apos;xiaozhang.超类型Person中name&apos;,xiaozhang.name); console.log(&apos;xiaozhang1.超类型Person中name&apos;,xiaozhang1.name); console.log(&apos;xiaozhang.构造函数中中love&apos;,xiaozhang.love); console.log(&apos;xiaozhang1.构造函数中love&apos;,xiaozhang1.love); console.log(&apos;xiaozhang.超类型的原型中sex&apos;,xiaozhang.sex); console.log(&apos;xiaozhang1.超类型的原型中sex&apos;,xiaozhang1.sex);// 构造函数的继承// 优点，不会改变引用类型的属性，能传递参数// 缺点无法复用方法； function Jianbo() &#123; Person.call(this,&apos;构造函数的继承&apos;) &#125; var xiaonie = new Jianbo(); console.log(&apos;构造函数的继承xiaonie.name可传参数&apos;,xiaonie.name); // xiaonie.go(); // 不存在// 组合继承// 原型链继承方法、构造函数继承属性 function Nb(love) &#123; Person.call(this,&apos;nb&apos;) this.love = love &#125; Nb.prototype = new Person(&apos;12&apos;); console.log(&apos;12&apos;,Nb.prototype.constructor ===Person) // true console.log(&apos;13&apos;,Nb.prototype.constructor ===Nb)// false 因为重写原型，会使原型失去了constructor属性 Nb.prototype.constructor =Nb console.log(&apos;14&apos;,Nb.prototype.constructor ===Person) // false Nb.prototype.say = function()&#123; console.log(&apos;say&apos;,&apos;say&apos;) &#125; var nb= new Nb(); var nb1= new Nb(&apos;组合继承&apos;); nb.name.push(&apos;xiaoniubi&apos;); console.log(&apos;nb.name&apos;,nb.name); console.log(&apos;nb1.name&apos;,nb1.name); console.log(&apos;nb1.love&apos;,nb1.love); nb.go(); nb.say();// 原型式继承Object.create() 将基础对象传给object()函数 // 本质是浅复制 副本的引用类型会被改变// 缺点：引用类型的属性会被共享 和原型链继承差不多// 使用场景： 让一个对象与另一个对象的保持类似function object(o)&#123; function F()&#123;&#125; F.prototype= o; return new F();&#125;var animal = &#123; name:&apos;原型式继承默认值&apos;, friends:[1,2,3,4]&#125;var haha= object(animal);var gaga = Object.create(animal);var haha1= object(animal);console.log(&apos;haha&apos;,haha.name);console.log(&apos;gaga&apos;,gaga.name);haha.name=&apos;原型式继承name值变了&apos;;haha.friends.push(&apos;原型式继承array值变了&apos;);console.log(&apos;haha&apos;,haha.name);console.log(&apos;haha1&apos;,haha1.name);console.log(&apos;haha&apos;,haha.friends);console.log(&apos;haha1&apos;,haha1.friends);// 寄生式继承// 能继承方法，但方法不能复用function createAnother(original)&#123; var clone = object(original); clone.say = function()&#123; console.log(&apos;寄生式继承方法&apos;) &#125; return clone;&#125;var hh = createAnother(animal);hh.name=&apos;寄生式继承&apos;console.log(&apos;hh&apos;,hh.name);hh.say() // 寄生组合式// 所有方式中最有效的方式 只调用继承的构造函数一次// 判断实例和原型的关系 使用instanceof 和 isPrototypeOf() console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Shuagnfeng); console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Person); console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Object); console.log(&apos;实例和原型的关系&apos;,Object.prototype.isPrototypeOf(xiaozhang)); console.log(xiaozhang.__proto__); 3.事件委托事件处理程序 获取事件对象 事件目标好处 减少DOM 操作 ，减少性能 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;list&quot;&gt; &lt;img id=&quot;1&quot; src=&quot;1.png&quot;&gt; &lt;img id=&quot;3.2.2&quot; src=&quot;3.2.2.png&quot;&gt; &lt;img id=&quot;3.2&quot; src=&quot;3.2.png&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var EventUtil = &#123; addHandler: function(element,type,handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type,handler,false) &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler:function(element,type,handler) &#123; if(element.removeEventListener) &#123; element.removeEventListener(type,handler,false) &#125; &#125;, getEvent:function(event)&#123; return event ? event : window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, &#125; var list = document.getElementById(&apos;list&apos;) EventUtil.addHandler(list,&apos;click&apos;,function(ev)&#123; event= EventUtil.getEvent(ev); var target = EventUtil.getTarget(event); alert(target.id); &#125;) // list.onclick = function(ev)&#123;// var ev = ev || window.event;// var target = ev.target || ev.srcElement;// console.log(target.id);// &#125; &lt;/script&gt; 4.跨域造成跨域的原因：浏览器的同源策略，即XMLHttpRequest(XHR)对象只能访问同一域中的资源这是种防止恶意行为的安全策略。第二个：浏览器中不同域的框架之间是不能进行js的交互操作的。 何谓同源:URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示它们同源。 在浏览器中，、、、等标签属于DOM， 非XHR对象，是可以加载跨域资源 跨域方法(实践中后两种最常用，所以重点介绍):(1) 通过jsonp跨域ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。(2) 通过修改document.domain来跨子域(3) 使用window.name来进行跨域(4) 使用HTML5中新引进的window.postMessage方法来跨域传送数据(5) 使用代理服务器,使用代理方式跨域更加直接，因为同源限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了。 123456使用本方法跨域步骤如下：1. 把访问其它域的请求替换为本域的请求2. 服务器端的动态脚本负责将本域的请求转发成实际的请求为了通过Ajax从http://localhost:8080访问http://localhost:8081/api，可以将请求发往http://localhost:8080/api。然后利用Apache Web服务器的Reverse Proxy功能做如下配置：ProxyPass /api http://localhost:8081/api (6) CORS全称是”跨域资源共享“（Cross-origin resource sharing),CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能 发送请求时，附加一个额外的Origin头部IE：XDR(XDomainRequest) 创建一个xdr实例，调用open() ,再send()方法；其他的，原生的支持，使用绝对的URL即可。 附：ajax的扩展，comment/Web Sockets(7) fetch api 5.输入url之后，到底发生了什么？ 6 JS引擎浏览器内核又可以分成两部分：渲染引擎(layout engineer或者RenderingEngine)和JS引擎。JS的引擎深入分析链接描述10分钟理解JS引擎的执行机制http://www.ruanyifeng.com/blo…JS引擎负责对JavaScript进行解释、编译和执行，以使网页达到一些动态的效果。 js的几种引入方式；js引擎是单线程 异步的— 任务队列 事件 和回调函数 Event Loop是通过的事件循环(event loop),实现单线程和异步的。单线程：同一时刻只能执行一个代码块将要执行的代码放在任务队列中，但js引擎执行代码块结束，事件循环会执行任务队列中的下一个任务。Event Loop 负责监控代码执行和管理任务队列。异步的，即可通过事件 回调等方式，向任务队列中添加新任务。 JS的执行机制是 首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table异步任务在event table中注册函数,当满足触发条件后,被推入event queue同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中以上三步循环执行,这就是event loop 准确的划分方式是:macro-task(宏任务)：包括整体代码script，setTimeout，setIntervalmicro-task(微任务)：Promise，process.nextTick按照这种分类方式:JS的执行机制是 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完重复以上2步骤,结合event loop(1) event loop(2) ,就是更为准确的JS执行机制了。 7 错误监控前端错误的分类 运行时错误（代码错误） 资源加载错误 接口错误 错误的捕获方式 运行时错误的捕获方式： 1234567try...catchwindow.onerror 含有详细的error信息 window.onerror = function(msg, url, lineNo, columnNo, error)&#123;&#125;window.addEventListener(&apos;error&apos;) window.addEventListener(&apos;error&apos;, event =&gt; &#123; console.log(&apos;addEventListener error:&apos; + event.target); &#125;, true); 资源加载错误： 123object.onerror（如img,script）performance.getEntries()Error事件捕获 接口错误： 12所有http请求都是基于xmlHttpRequest或者fetch封装的。所以要捕获全局的接口错误，方法就是封装xmlHttpRequest或者fetch 结论1.使用window.onerror捕获JS运行时错误2.使用window.addEventListener(‘unhandledrejection’)捕获未处理的promise reject错误3.重写console.error捕获console.error错误4.在跨域脚本上配置crossorigin=”anonymous”捕获跨域脚本错误window.addEventListener(‘error’)捕获资源加载错误。因为它也能捕获js运行时错误，为避免重复上报js运行时错误，此时只有event.srcElement inatanceof HTMLScriptElement或HTMLLinkElement或HTMLImageElement时才上报5.重写window.XMLHttpRequest和window.fetch捕获请求错误 延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？ 1234可以。Script error1.在script标签增加crossorigin属性2.设置js资源响应头Access-Control-Allow-Orgin:* 上报错误的基本原理 121. 采用Ajax通信方式上报2. 利用Image对象上报 https://segmentfault.com/a/1190000014728771#articleHeader19","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"基本类型和引用类型的值","slug":"变量、作用域与内存问题","date":"2019-02-01T16:00:00.000Z","updated":"2019-05-12T03:46:35.933Z","comments":true,"path":"2019/02/02/变量、作用域与内存问题/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/02/变量、作用域与内存问题/","excerpt":"","text":"4.1基本类型和引用类型的值ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 数据类型: 基本类型值：Undefined、Null、Boolean、Number、String； 引用类型值，也就是对象类型：Object、Array、Function、Date等； 声明变量时不同的内存分配 基本类型值：存储在栈（stack）中的简单数据段，它们的值直接存储在变量访问的位置。这是因为这些基本类型占据的空间是固定的，所以可以将它们存储在较小的内存区域- 栈中。这样存储更便于迅速查寻变量的值。 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 不同的内存分配机制也带来了不同的访问机制 在javascript中是不允许直接访问保存在堆内存中的对象的，也就是说不能直接操作对象的内存空间。所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。 注意：当复制保存着对象的某个变量时，操作的事对象的引用。但在为对象添加属性时，操作的是实际的对象 复制变量的不同 基础类型值：在将一个保存着基础类型值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count); //20 没有变化console.log(result); //30 引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了） 123456function setName(obj) &#123; obj.name = &quot;Nicholas&quot;;&#125;var person = new Object();setName(person);console.log(person.name); //&quot;Nicholas&quot; 参数传递的不同首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到基础类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。 基础类型值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 引用类型值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧： 所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！来看下面这个例子吧：（传说中的call by sharing） 12345678910111213141516171819var obj1 = &#123; value:&apos;111&apos;&#125;; var obj2 = &#123; value:&apos;222&apos;&#125;; function changeStuff(obj)&#123; obj.value = &apos;333&apos;; obj = obj2; return obj.value;&#125; var foo = changeStuff(obj1); console.log(foo);// &apos;222&apos; 参数obj指向了新的对象obj2console.log(obj1.value);//&apos;333&apos; obj1仍然指向原来的对象,之所以value改变了,是因为changeStuff里的第一条语句，这个时候obj是指向obj1的 .再啰嗦一句，如果是按引用传递的话，这个时候obj1.value应该是等于&#39;222&#39;的 可以把ECMAScript函数的参数想象成局部变量 4.1.4 检测类型如果变量的值是一个对象或null，则typeof操作符会返回&quot;object&quot;. 通常我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符； 如果对象是给定引用类型的实例，那么instanceof操作符就会返回true。 123console.log(person instanceof Object); //变量person是Object吗？console.log(colors instanceof Array); //变量colors是Array吗？console.log(pattern instanceof RegExp); //变量pattern是RegExp吗? 根据规定，所有引用类型的值都是Object的实例。在检查一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。 4.2执行坏境和作用域每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。 每个环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它 当代码在一个环境执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问 4.2.1 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。 try-catch 语句中的 catch 块 with 语句 对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 123456789101112131415var oMyself = &#123; sFirstname: &quot;Aidan&quot;, sLastName: &quot;Dai&quot;&#125;function create()&#123; var sLastName = &quot;Wen&quot; with(oMyself)&#123; //将oMyself作为自己的执行环境 sAllName = sFirstname +&quot; &quot; + sLastName; &#125; return sAllName;&#125;var sMyName = create();console.log(sMyName); //Aidan Dai 4.2.2 没有块级作用域对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。 1. 声明变量使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近环境的就是函数的局部环境；在with语句中，最接近的环境就是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。 注意：在编写JavaScript中，不声明而直接初始化变量时一个错误的做法，因为这样可能会导致意外。在严格模式下，初始化未经声明的变量会导致错误。 2.查询标识符搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境找到，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域向上搜索。搜索过程将一直追溯到全局环境的变量对象。在全局环境也没找到的话则说明该变量尚未声明。 1234567var color = &quot;blue&quot;;function getColor() &#123; return color;&#125;console.log(getColor()); //&quot;blue&quot;; 4.3 垃圾收集JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 变量生命周期 什么叫不再使用的变量？不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包中由于内部函数的原因，外部函数并不能算是结束 一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。貌似很简单的工作，为什么会有很大开销呢？这仅仅是垃圾回收的冰山一角，就像刚刚提到的闭包，貌似函数结束了，其实还没有，垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用的策略有很多，常见的有两种方式 4.3.1 标记清除这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 4.3.2 引用计数在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 4.3.3 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。 事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议这样做。在IE中调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。 4.3.4管理内存确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要数据。一旦数据不再可用，最好通过将其值设置为null来释放其引用——这个方法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象属性。局部变量会在它们离开执行环境时自动被解除引用。 12345678910function createPerson(name) &#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson(&quot;Nicholas&quot;);//手工解除globalPerson的引用globalPerson = null; 4.4 小结基本类型值和引用类型值具有以下特点: 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值得变量实际上包含的并不是对象本身，而是指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 https://segmentfault.com/a/1190000008929249#articleHeader0","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"JS基础","slug":"js核心知识(基础)","date":"2019-01-31T16:00:00.000Z","updated":"2019-05-12T03:46:35.919Z","comments":true,"path":"2019/02/01/js核心知识(基础)/","link":"","permalink":"https://WLL-1017065322.github.io/2019/02/01/js核心知识(基础)/","excerpt":"","text":"JS基础1.数据类型？6基本数据类型： Undefined, Null, Boolean, Number, String ,Symbol引用类型： Array Object Date Function 区别：基本类型值保存在栈空间，我们通过按值来访问的。引用类型，的值是对象，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。1.基本数据类型不可以添加/删除属性和方法；2.复制的方式不同；引用类型复制的时候，复制的是指针，2个变量实际指的是同一个对象。3.函数的参数是按值传递的检测数据类型 typeof instanceof转型数据类型 12显式：Boolean()/Number()/pareseInt()/pareseFloat()/toString()/String()隐私： +、 赋值 区别： undefined与null 的区别 null： 1234是Null类型的值.是个空值，空对象指针.typeof null，结果为Object;null用来表示尚未存在的对象. undefined : 12345是Undefined类型的值。typeof undefined，结果为undefined;一个声明了变量，但未初始化值，结果就是undefined没有返回值的函数，返回的也是undefined,没有实参的形参也是undefined; symbol表示独一无二的值Symbol 值通过Symbol函数生成对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。因为symbol的每个值不相等。Symbol 值不能与其他类型的值进行运算，会报错Symbol 值可以显式转为字符串。Symbol 值也可以转为布尔值，但是不能转为数值Symbol 值作为对象属性名时，不能用点运算符。 2.面向对象？何为面向对象 万物皆对象， 对象又有如下特点：  抽象：抓住核心问题 封装：只能通过对象来访问方法 继承：从已有的对象下继承出新的对象 多态：多对象的不同形态创建对象的5种方式 1.工厂方式创建对象：面向对象中的封装函数(内置对象) 2.构造函数创建对象 优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方 缺点：每个方法都要在每个实例上重新创建一遍 3、对象字面量方式创建对象 4、用原型方式  1、优点：可以让所有的对象实例共享它所包含的属性和方法 2、缺点：原型中是所有属性都是共享的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。 5.混合模型：构造函数模式定义实例属性，而原型模式用于定义方法和共享的属性总结：使用上述的混合法 3.Array数组的增加 1234567array.push() 向数组末尾添加元素，返回的是添加后新数组的长度，原有数组改变array.unshift() 向数组开头添加元素，返回的是添加后新数组的长度，原有数组改变array.splice(n,m) 从索引n开始删除m个元素，把删除的内容当做新数组返回，原有数组array.concat()// ES6的合并数组[...arr1, ...arr2, ...arr3]Array.prototype.push.apply(arr1,arr2);)----将arr2追加到arr1中，返回数组的长度 数组的删除 12345array.pop() 删除数组的最后一项，返回的是删除的那一项，原有数组改变array.shift() 删除数组的的第一项，返回的是删除的那一项，原有数组改变splice(n,m,x) 从索引n开始删除m个元素，然后插入元素x，把删除的内容当做新数组返回，原有数组改变。作删除使用，x不传入数据既可。slice(n,m) 从索引n开始删除m个元素,返回删除项，原数组不变length 减小数组的长度，实际是从数组尾部删除元素，改变原数组。 改 1其实只有一种 splice(),但delete方法，我个人感觉算修改不属于删除，详情请见实例 查 12345678indeOf() lastIndexOf()find()findIndex()includes()[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5[1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0) // 2[1, 2, 3].includes(2) // true 排序array.reverse() 把数组倒过来排序，原有数组改变array.sort() 可以实现由大到小或者由小到大的排序 但是直接写sort只能排序十以内的数字 3.1类型转换数组 对象 字符串 的转换； array –&gt;string： 12join(&quot;+&quot;) 把数组的每一项拿出来用指定分隔符隔开 ；tostring 把数组的每一项拿出来用逗号隔开，原有数组不变 obj –&gt; string 12JSON.parse(); //可以将json字符串转换成json对象JSON.stringify(); //可以将json对象转换成json对符串 string–&gt;array: 1split(“,”) obj –&gt; array： 12For… in循环赋值法Array.from() number –&gt; array 1Array.of() string –&gt; number (4种) 1234Number() parseFloat() // 如果parseInt()和parseFloat()不能够把指定的字符串转换为数字，它们就会返回NaN parseInt(&apos;&apos;eleven&quot;); // Returns Nan parseInt() // parseInt()是取整，即丢弃小数部分,保留整数部分 parseInt(2.7) ==&gt;3 +number // var c = +&apos;2&apos; typeof c ---number string &lt;– number (4种)var c = String(number)var c = number + ‘’var c = number.toString(8) // 将number 转换成8进制的数字 且c的类型是stringvar c = number.toFixed(1); //数字转换为字符串，并且显示小数点后的指定的位数 例 number = 123.476,则c= 123.5” 深浅拷贝对象和数组的拷贝有两种浅拷贝即 拷贝了指针指向，当一个对象的值改变会影响另一个对象的值。深拷贝， 拷贝的是真正的值。2者相互独立，互不干扰。浅拷贝的方法4种方法slice() concat() 赋值法 遍历注：concat 和 slice 对一维数组 能算是深拷贝;2维的 是浅拷贝 123456789101112131415161718192021222324252627282930var a= [1,2,3,4]b= a.concat();c=a.concat();b[0] = 5;c[0] = 6;a // [1,2,3,4]b // [5,2,3,4]c // [6,2,3,4]var aa= [[1,1],[2,2],3,4]bb= aa.concat();cc=aa.concat();bb[1][0] = 5;cc[0] = 6;aa // [[1,1],[5,2],3,4]b // [[1,1],[5,2],3,4]c // [6,[5,2],3,4]var shallowCopy = function(obj) &#123;// 只拷贝对象if (typeof obj !== &apos;object&apos;) return;// 根据obj的类型判断是新建一个数组还是对象var newObj = obj instanceof Array ? [] : &#123;&#125;;// 遍历obj，并且判断是obj的属性才拷贝for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125;&#125;return newObj;&#125; 深拷贝的方法5种方法：一维数组和对象的concat slice法 JSON.parse(JSON.stringify(arr)) 和遍历法 解构赋值法示例：（前3种毕竟简单，这里也不表述）解构赋值法：const a1 = [1, 2]; const a2 = […a1];或者const […a2] = a1; 1234567891011var deepCopy = function(obj) &#123;if (typeof obj !== &apos;object&apos;) return;var newObj = obj instanceof Array ? [] : &#123;&#125;;for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === &apos;object&apos; ? deepCopy(obj[key]) : obj[key]; &#125;&#125;return newObj;&#125; 还有一些常用方法如filter() forEach() map() every() some() 详情请见：最全最细致的数组的方法整理 es5+es6 5.对象的属性ES5的属性特性包括下面六个： configurable: 表示能否通过delete来删除属性从而重新定义属性，能够修改属性的特性,默认为true enumberable: 表示是否能通过for-in循环返回属性。默认为true writable: 是否可以修改属性, 默认为true value: 包含这个属性的数据值。读取属性值时3,从这个属性读，写入属性时，把新值保存到这个位置。默认值为undefine. getter: 在读取属性时，调用的函数 setter: 在写入属性时调用的函数 特别注意：一旦调用了Object.defineProperty方法之后，那些未定义的特性值除了configurable为false之外，其他都为undefined; 6.DOM DOM是针对HTML和XML文档的一个API(应用程序编程接口). DOM描绘了一个层次化的节点树, 允许开发人员添加, 移除和修改页面的某一部分. 常用的DOM方法:1)查找a) getElementById(id) //通过元素Id，唯一性b) getElementsByTagName() //通过标签名称c) getElementsByName() //通过元素的Name属性的值(IE容错能力较强， 1会得到一个数组，其中包括id等于name值的) 2）添加、移除、替换、插入 复制c) appendChild(node) // 可添加 可移动位置;可添加元素 可添加文本d) removeChild(node)e) replaceChild(取代别人的mode,已有节点) // 替换已有节点f) insertBefore(插入节点,已有节点) //在已有的子节点前插入一个新的子节点g) cloneNode(true/false) //深浅复制 3)创建 123createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 div p span createTextNode() //创建一个文本节点 4)i) getAttribute()j) setAttribute() 5 常用的DOM属性a) innerHTML 节点(元素)的文本值b) parentNode 节点(元素)的父节点c) childNodesd) attributes 节点(元素)的属性节点 6.两个节点的关系 7.JS获取盒模型宽高为了方便书写，以下用dom来表示获取的HTML的节点。 dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。 但这种方式只有IE浏览器支持。 window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 dom.offsetWidth/offsetHeight这个就没什么好说的了，最常用的，也是兼容最好的。 8.通用的事件侦听器主要考核 事件处理程序 和event对象及其属性和方法 12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123; addHandler: function(element,type,handler) &#123;//添加事件处理程序 if(element.addEventListener) &#123; element.addEventListener(type,handler,false) &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler:function(element,type,handler) &#123;//移除事件处理程序 if(element.removeEventListener) &#123; element.removeEventListener(type,handler,false) &#125; &#125;, getEvent:function(event)&#123;// 获取事件对象 return event ? event : window.event; &#125;, getTarget:function(event)&#123;// 获取事件的目标 return event.target || event.srcElement; &#125;, preventDefault()&#123; (event) =&gt;&#123; if(event.preventDefault)&#123;event.preventDefault()&#125; else &#123;event.returnValue= false&#125; &#125; &#125;, stopPropagation()&#123; (event) =&gt;&#123; if(event.stopPropagation)&#123;event.stopPropagation()&#125; else &#123;event.cancelBubble= true;&#125; &#125; &#125; &#125; var list = document.getElementById(&apos;list&apos;) EventUtil.addHandler(list,&apos;click&apos;,function(ev)&#123; event= EventUtil.getEvent(ev); var target = EventUtil.getTarget(event); alert(target.id); &#125;) 9.实现点击ul中li元素方法有很多，闭包法、立即执行函数法、、事件委托法；但本题主要考核 DOM事件流 利用事件委托，减少dom操作，提高性能 123456var list = document.getElementById(&apos;list&apos;) list.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; console.log(target.id); &#125; 10.Ajax原生的写法 1234567891011121314151617var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; console.log(xhr.status) if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304)&#123; var hh = xhr.responseText; var haha1 = document.getElementById(&apos;wokao&apos;); haha1.innerHTML = hh; &#125;else&#123; alert(&apos;failed11&apos;,xhr.status); &#125; &#125; &#125; xhr.open(&quot;get&quot;,&quot;http://10.10.65.109:8888/text.json&quot;,true); xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); // xhr.responseType = &quot;json&quot;; xhr.send(null); 何为异步？ 异步与同步的概念实现异步的方法：回调 事件 promiseAjax最大特性：可以实现动态不刷新（局部刷新）.优点： 123通过异步模式，提升了用户体验优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 缺点 12345671、ajax不支持浏览器back按钮。2、安全问题 AJAX暴露了与服务器交互的细节。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、不容易调试。**post 和get的区别：**  GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。当然在Ajax请求中，这种区别对用户是不可见的。 GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 “GET方式提交的数据最多只能是1024字节”，post无 get请求和post请求在服务器端的区别:在客户端使用get请求时,服务器端使用Request.QueryString来获取参数,而客户端使用post请求时,服务器端使用Request.Form来获取参数. 12**适用场景：**POST用于创建资源，资源的内容会被编入HTTP请示的内容中。例如，处理订货表单、在数据库中加入新数据行等。 当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。 1若符合下列任一情况，则用POST方法： 请求的结果有持续性的副作用，例如，数据库内添加新的数据行。 若使用GET方法，则表单上收集的数据可能让URL过长。 要传送的数据不是采用7位的ASCII编码。若符合下列任一情况，则用GET方法： 请求是为了查找资源，HTML表单数据仅用来帮助搜索。 请求结果无持续性的副作用。 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。 对cookie localStorage sessionStorage的理解 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 1**cookie:**  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 作用域不同: sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。 Web Storage 的 api 接口使用更方便。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。总之：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生cookie优点：极高的扩展性和可用性 缺点： 数量和长度受限、安全问题cookie 和session 的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 1考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 1考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议： 12将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 12.IE的不同之处IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 13.this工作原理原则，那就是this指的是调用函数的那个对象。 javascript 的this主要是看如何调用这个函数，而不是这个函数所在的作用域。obj.fn() fn中的 this 就是 obj。 fn() this是undifine, 而在js进入函数之前，会有 if(!this) { this = window} 这样的操作。 this 一共有六种不同的值： 普通函数调用，this为全局对象或是undefined 作为对象的方法，this为那个对象 new 表达式，this为以该函数为原型的新创建的对象 使用 apply/call指定 this 用bind绑定固定的this 事件处理函数中的this是当前的触发事件的DOM元素(event.currentTarget)IE attachEvent添加的事件处理函数中this为window 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;this&lt;/title&gt;&lt;/head&gt;&lt;body&gt;在严格模式下，一般的函数调用中 this 的值是 undefined。&lt;button onclick=&quot;console.log(this)&quot; &gt; show this&lt;/button&gt;&lt;p id=&quot;hahah&quot;&gt;测试DOM元素(event.currentTarget)&lt;/p&gt;&lt;p id=&quot;ha&quot;&gt;测试DOM元素IE&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;var obj=&#123;a:1&#125;;var aa = function func(a,b)&#123; console.log(&apos;this&apos;,this); console.log(&apos;this&apos;,a); return 1;&#125;var bb = function funb()&#123; console.log(&apos;this&apos;,this); &#125;bb.prototype= new aa();//obj.f = aa;/*作为对象的方法 ***/obj.f(123);//输出 obj 123aa(123); //输出 window 123(obj.f)();// obj 没懂(a=obj.f)(); // window(0,obj.f)(); // window/*call spply bind中this***/aa.call(&apos;call&apos;,1);// call 1aa.apply(&apos;apply&apos;,[1]); // apply 1var cc = aa.bind(&apos;bind&apos;,1); cc(22); //bind 1var cc1 = new cc(33)// func 1/***new 表达式，this为以 该函数为原型 的新创建的对象*/var dd = new aa(11,22); // func &#123;&#125;var bb1 = new bb();/****事件处理函数中的this**当前的触发事件的DOM元素(event.currentTarget)**IE attachEvent添加的事件处理函数中this为window*/function evtHandle(e)&#123; console.log(&apos;e.currentTarget.id&apos;,this.id); // console.log(&apos;e.target.id&apos;,this.id); // &#125;var elements = document.getElementById(&apos;hahah&apos;);var elements1 = document.getElementById(&apos;ha&apos;);elements.addEventListener(&apos;click&apos;,evtHandle,false);// ie专属 chrome下报错 // elements1.attachEvent(&apos;onclick&apos;,evtHandle);obj = &#123; go: function() &#123; console.info(&apos;oo&apos;,this) &#125; &#125;;(0 || obj.go)() // window&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 14.函数1.函数的调用方式 方法调用模型 var obj = { func : function(){};} obj.func() 函数调用模式 var aa = function(){} aa(); 构造器调用模式 apply/ call调用模式 立即执行函数(function(){}()) 区别：函数调用模式，有函数提升的；即aa() 无需必须在var aa = function(){} 后面 2.return的含义 注：return不一定非得用在function 中，也可以直接放在html中，如:onsubmit=”return false”; 语法：return 表达式;含义：语句结束函数执行，返回调用函数，而且把表达式的值作为函数的结果通常函数经过一系列的处理后需要给外部返回一个值,这个值一般用return返回出去,也可以是说return是向函数返回返回值,并终止函数的运行. return; 123含义：即 return null 无函数返回值；能中断方法的执行，但无法阻止事件的默认行为。把控制权返回给页面。 return false; 12345含义：相当于终止符；1. 一般是用来取消默认动作的。比如，终止表单提交。比如你单击一个链接除了触发你的onclick事件外还会触发一个默认事件就是执行页面的跳转。所以如果你想取消对象的默认动作（event.preventDefault();）就可以return false。2. return false 只在当前函数有效，不会影响其他外部函数的执行 retrun true； 12含义：相当于执行符。执行终止默认的事件行为 返回正确的处理结果。 15.闭包 闭包是指有权访问另一个函数作用域中的变量的函数. 创建闭包常见方式,就是在一个函数内部创建另一个函数.作用:1.匿名自执行函数 (function (){ … })(); 创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。2.缓存, 可保留函数内部的值3.实现封装4.实现模板5.给了js函数生成函数的能力，增加了js代码的抽象能力缺点1.造成内存泄露；变量内存无法被标记，导致内存不会被垃圾回收机制回收。为什么要用局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。如何使用1.定义外层函数，封装被保护的局部变量。2.定义内层函数，执行对外部函数变量的操作。3.外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。 123456789var getNum;function getCounter() &#123; var n = 1; var inner = function () &#123; return n++; &#125; return inner;&#125;getNum = getCounter();console.log(getNum()); //1 2 3 4 16.call aplly bindapply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；apply 、 call 、bind 三者都可以利用后续参数传参；bind是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 123456789101112131415161718192021function fn(a,b)&#123; console.log(this); console.log(a); console.log(b);&#125;// bind(this,args...)bf = fn.bind(&quot;Bind this&quot;,10); // 没有任何输出，也就是说没有执行这个函数bf(); // &quot;Bind this&quot;,10,undefinedbf(20);// “Bind this”,10,20// 原函数不受影响fn(1,2); //window， 1，2bf2 = fn.bind(&quot;Bind this&quot;,1,2);bf2(); // &quot;Bind this&quot;,1,2// call(this,args...)fn.call(&quot;Call this&quot;,1) // &quot;Call this&quot;,1,undefinedfn.call(&quot;Call this&quot;,1,2) // &quot;Call this&quot;,1,2// apply(this,[args])fn.apply(&quot;Apply this&quot;,[1]) // &quot;Apply this&quot;,1,undefinedfn.apply(&quot;Apply this&quot;,[1,2]) // &quot;Apply this&quot;,1,2 17.js语言特性特性，即封装、继承、多态此处内容较多，便不详细叙述。注意一下继承的方式继承6方式： 1、拷贝继承：通用型 有new无new都可以用 2、类式继承：new构造函数—利用构造函数（类）继承的方式 3、原型继承：无new的对象—借助原型来实现对象继承对象 4. 属性继承：调用父类的构造函数call 5. 方法继承：用for in的形式 拷贝继承（jq也用拷贝继承） 18.”use strict”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向 19.加载方式1.延迟加载有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。JS延迟加载有助于提高页面加载速度。 js的进程由解析和执行构成。所有的延迟加载方式都只是延迟了执行过程。解析从未停止js的执行顺序是自上而下。延迟加载几种方式： 123456defer 属性 defer的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。async 属性 async的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染，下载好了 就执行。动态创建DOM方式 document.createElement 使用jQuery的getScript方法使用setTimeout延迟方法让JS最后加载（放在文档尾部） 2.同步加载，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 3.异步加载：也就是说第一个fun请求数据时，数据还未返回时便开始执行第二个fun了代表：ajax 回调 事件 promise 4.预加载一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源，当用户访问某个预加载的链接时，如果从缓存命中,页面就得以快速呈现5.图片延迟加载的方式 https://segmentfault.com/a/1190000014728771#articleHeader19","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/tags/javascript/"}],"author":"along"},{"title":"Hello World","slug":"Hello World","date":"2017-06-17T16:00:00.000Z","updated":"2019-05-12T03:46:35.828Z","comments":true,"path":"2017/06/18/Hello World/","link":"","permalink":"https://WLL-1017065322.github.io/2017/06/18/Hello World/","excerpt":"MinHow-This is a summary","text":"MinHow-This is a summary","categories":[{"name":"First","slug":"First","permalink":"https://WLL-1017065322.github.io/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"https://WLL-1017065322.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"https://WLL-1017065322.github.io/tags/Second/"}],"author":"MinHow"},{"title":"hexo 的第一篇文章","slug":"hexo 的第一篇文章","date":"2017-03-27T05:48:25.000Z","updated":"2019-05-12T03:46:35.918Z","comments":true,"path":"2017/03/27/hexo 的第一篇文章/","link":"","permalink":"https://WLL-1017065322.github.io/2017/03/27/hexo 的第一篇文章/","excerpt":"","text":"hexo 的第一篇文章","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://WLL-1017065322.github.io/categories/Algorithm/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://WLL-1017065322.github.io/tags/标签1/"},{"name":"标签2 (可选)","slug":"标签2-可选","permalink":"https://WLL-1017065322.github.io/tags/标签2-可选/"}]}]}